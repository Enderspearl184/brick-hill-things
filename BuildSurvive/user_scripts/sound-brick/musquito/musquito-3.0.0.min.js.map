{"version":3,"sources":["webpack://$buzz/webpack/universalModuleDefinition","webpack://$buzz/webpack/bootstrap","webpack://$buzz/./src/Utility.js","webpack://$buzz/./src/DownloadStatus.js","webpack://$buzz/./src/Engine.js","webpack://$buzz/./src/DownloadResult.js","webpack://$buzz/./src/Emitter.js","webpack://$buzz/./src/Queue.js","webpack://$buzz/./src/Sound.js","webpack://$buzz/./src/Buzz.js","webpack://$buzz/./src/BufferLoader.js","webpack://$buzz/./src/MediaLoader.js","webpack://$buzz/./src/Html5AudioPool.js","webpack://$buzz/./src/WorkerTimer.js","webpack://$buzz/./src/LoadState.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Utility","_navigator","_contextType","_formats","_userAgent","navigator","this","userAgent","AudioContext","webkitAudioContext","audio","Audio","mp3","Boolean","canPlayType","replace","mpeg","opus","ogg","oga","wav","aac","caf","m4a","mp4","weba","webm","dolby","flac","Math","round","Date","now","random","format","formats","find","isFormatSupported","source","ext","isBase64","exec","toLowerCase","sources","isSourceSupported","str","test","maxTouchPoints","msMaxTouchPoints","pause","isIE","src","onerror","onend","canplaythrough","Success","Failure","ErrorType","NoAudio","LoadError","PlayError","EngineError","EngineState","NotReady","Ready","Suspending","Suspended","Resuming","Destroying","Done","EngineEvents","Init","Volume","Mute","Stop","Suspend","Resume","Error","userInputEventNames","engine","_id","utility","id","_muted","_volume","_maxNodesPerSource","_cleanUpInterval","_inactiveTime","_autoEnable","_intervalId","_isAudioAvailable","_state","_context","_gainNode","_queue","_buzzesArray","_soundsArray","_bufferLoader","_mediaLoader","_sourceRegistry","Queue","_resumeAndRemoveListeners","free","args","getContext","_fire","type","error","volume","muted","maxNodesPerSource","cleanUpInterval","inactiveTime","autoEnable","preload","progress","oninit","onstop","onmute","onvolume","onsuspend","onresume","ondone","on","BufferLoader","MediaLoader","x","_freeSounds","forEach","buzz","getCompatibleSource","state","eventName","document","addEventListener","createGain","gain","setValueAtTime","currentTime","connect","destination","setInterval","keys","register","getCompatibleSrc","map","f","Array","isArray","url","_getCompatibleSource","bufferUrls","values","filter","stream","mediaUrls","Promise","all","load","loadMedia","then","result","idOrSoundArgs","sound","play","audioSrc","audioFormat","audioSprite","spriteSound","soundArgs","startsWith","parts","split","substring","_getSourceInfo","sprite","rate","loop","loadCallback","playEndCallback","destroyCallback","fadeEndCallback","audioErrorCallback","length","setup","isAudioAvailable","compatibleSrc","_removeSound","releaseForSound","positions","startPos","endPos","Sound","_gain","push","allocateForGroup","downloadResult","status","DownloadStatus","allocateForSound","_play","stop","buzzes","sounds","mute","unmute","vol","undefined","to","duration","fade","fadeStop","seek","destroy","add","suspend","run","resume","cleanUp","clearInterval","dispose","clear","emitter","remove","terminate","close","urls","progressCallback","indexOf","splice","groupId","soundId","unload","releaseForGroup","hasFreeNodes","handler","once","off","getSource","sourceInfo","fire","getSupportedFormat","getSupportedSource","inactiveDurationInSeconds","lastPlayed","isPersistent","isPlaying","isPaused","default","Emitter","_objectsEventsHandlersMap","_hasObject","objEvents","_hasEvent","eventSubscriber","eventSubscribers","setTimeout","subscriber","_eventActions","actionIdentifier","action","removeAfterRun","hasEvent","fn","_run","hasAction","queued","SoundState","Playing","Paused","Destroyed","_rate","_loop","_stream","_buffer","_audio","_bufferSourceNode","_duration","_startPos","_endPos","_currentPos","_rateSeek","_startTime","_loadCallback","_playEndCallback","_destroyCallback","_fading","_fadeTimer","_fadeEndCallback","_audioErrorCallback","_mediaElementAudioSourceNode","_endTimer","_isSprite","_lastPlayed","_persist","_sourceExists","_loaded","_onBufferEnded","_onHtml5Ended","_onCanPlayThrough","_onAudioError","buffer","playbackRate","_setLoop","context","createMediaElementSource","canPlay","_playHtml5","_playBuffer","removeEventListener","_clearEndTimer","_destroyBufferNode","linearRampToValueAtTime","exponentialRampToValueAtTime","workerTimer","clearTimeout","cancelScheduledValues","_getTimeVars","abs","realTime","rateElapsed","_destroyAudio","_destroyMediaSourceNode","disconnect","readyState","err","max","createBufferSource","startTime","start","noteGrainOn","timeout","noteGrainOff","loopStart","loopEnd","BuzzState","BuzzEvents","Load","LoadProgress","UnLoad","PlayStart","PlayEnd","Pause","Seek","Rate","FadeStart","FadeEnd","FadeStop","Destroy","Buzz","_src","_format","_sprite","_preload","_autoplay","_compatibleSrc","_loadState","LoadState","NotLoaded","_noOfLoadCalls","_audioNodes","_engine","_onLoadProgress","_setSource","autoplay","onload","onloadprogress","onunload","onplaystart","onplayend","onpause","onrate","onseek","ondestroy","masterGain","_onEngineResume","Loading","Loaded","_onLoadFailure","soundOrId","newSoundId","newSound","playSound","isLoaded","isGroup","_removePlayActions","_sounds","persist","abandon","evt","percentageDownloaded","playAndFire","$buzz","method","arguments","_bufferCache","_progressCallsAndCallbacks","_disposed","_load","_unload","resolve","DownloadResult","reject","decodeAudioData","arrayBuffer","data","atob","dataView","Uint8Array","charCodeAt","req","XMLHttpRequest","open","responseType","response","lengthComputable","loaded","total","send","soundCleanUpCallback","_audioPool","_bufferingAudios","Html5AudioPool","removeAudioObjOfUrl","audioObj","a","_cleanUp","releaseForSource","release","releaseAudio","allocateForSource","onCanPlayThrough","obj","onError","_soundCleanUpCallback","_resourceNodesMap","_cleanUpCalled","_createSrc","_checkMaxNodesForSrc","unallocated","time","_createGroup","nodes","allocated","shift","notAllocatedAudioObj","_destroyNode","node","soundIdOrAudio","allocatedAudioObj","inactiveNodes","totalAllocatedLength","WorkerTimer","_worker","_isWorkerThreadAvailable","_timerCallbacks","_timerId","_handleMessage","Worker","blob","_getBlob","WORKER_SCRIPT","workerUrl","_createObjectURL","script","Blob","e","blobBuilderType","BlobBuilder","WebKitBlobBuilder","append","getBlob","file","URL","createObjectURL","webkitURL","callback","timerId","cb","repeat","postMessage","command","timeoutId","intervalId"],"mappings":"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","file":"musquito-3.0.0.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"$buzz\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"$buzz\"] = factory();\n\telse\n\t\troot[\"$buzz\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","/**\n * Contains helper methods.\n */\nclass Utility {\n\n  /**\n   * The navigator object.\n   * @type {Navigator}\n   * @private\n   */\n  _navigator = null;\n\n  /**\n   * The AudioContext type.\n   * @type {Function}\n   * @private\n   */\n  _contextType = null;\n\n  /**\n   * Dictionary of audio formats and their support status.\n   * @type {object}\n   * @private\n   */\n  _formats = {};\n\n  /**\n   * User agent.\n   * @private\n   */\n  _userAgent = null;\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    if (typeof navigator !== 'undefined') {\n      this._navigator = navigator;\n      this._userAgent = navigator.userAgent;\n    }\n\n    // Set the available Web Audio Context type available in browser.\n    if (typeof AudioContext !== 'undefined') {\n      this._contextType = AudioContext;\n    } else if (typeof webkitAudioContext !== 'undefined') {\n      this._contextType = webkitAudioContext;\n    }\n\n    // Determine the supported audio formats.\n    let audio = new Audio();\n\n    this._formats = {\n      mp3: Boolean(audio.canPlayType('audio/mp3;').replace(/^no$/, '')),\n      mpeg: Boolean(audio.canPlayType('audio/mpeg;').replace(/^no$/, '')),\n      opus: Boolean(audio.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, '')),\n      ogg: Boolean(audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')),\n      oga: Boolean(audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')),\n      wav: Boolean(audio.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, '')),\n      aac: Boolean(audio.canPlayType('audio/aac;').replace(/^no$/, '')),\n      caf: Boolean(audio.canPlayType('audio/x-caf;').replace(/^no$/, '')),\n      m4a: Boolean((audio.canPlayType('audio/x-m4a;') ||\n        audio.canPlayType('audio/m4a;') ||\n        audio.canPlayType('audio/aac;')).replace(/^no$/, '')),\n      mp4: Boolean((audio.canPlayType('audio/x-mp4;') ||\n        audio.canPlayType('audio/mp4;') ||\n        audio.canPlayType('audio/aac;')).replace(/^no$/, '')),\n      weba: Boolean(audio.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n      webm: Boolean(audio.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n      dolby: Boolean(audio.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, '')),\n      flac: Boolean((audio.canPlayType('audio/x-flac;') || audio.canPlayType('audio/flac;')).replace(/^no$/, ''))\n    };\n\n    audio = null;\n  }\n\n  /**\n   * Returns an unique id (credit: https://howlerjs.com).\n   * @return {number}\n   */\n  id() {\n    return Math.round(Date.now() * Math.random());\n  }\n\n  /**\n   * Returns the available context type.\n   * @return {Function}\n   */\n  getContextType() {\n    return this._contextType;\n  }\n\n  /**\n   * Instantiates and returns the audio context.\n   * @return {AudioContext|webkitAudioContext}\n   */\n  getContext() {\n    return new this._contextType();\n  }\n\n  /**\n   * Returns the supported audio formats.\n   * @return {Object}\n   */\n  supportedFormats() {\n    return this._formats;\n  }\n\n  /**\n   * Returns true if the passed format is supported.\n   * @param {string} format The audio format ex. \"mp3\"\n   * @return {boolean}\n   */\n  isFormatSupported(format) {\n    return Boolean(this._formats[format]);\n  }\n\n  /**\n   * Returns the first supported format from the passed array.\n   * @param {string[]} formats Array of audio formats\n   * @return {string}\n   */\n  getSupportedFormat(formats) {\n    return formats.find(format => this.isFormatSupported(format));\n  }\n\n  /**\n   * Returns true if the audio source is supported.\n   * @param {string} source The audio source url or base64 string\n   * @return {boolean}\n   */\n  isSourceSupported(source) {\n    let ext = this.isBase64(source) ?\n      (/^data:audio\\/([^;,]+);/i).exec(source) :\n      (/^.+\\.([^.]+)$/).exec(source);\n\n    ext = (/^.+\\.([^.]+)$/).exec(source);\n    return ext ? this.isFormatSupported(ext[1].toLowerCase()) : false;\n  }\n\n  /**\n   * Returns the first supported audio source from the passed array.\n   * @param {string[]} sources Array of audio sources. The audio source could be either url or base64 string.\n   * @return {string}\n   */\n  getSupportedSource(sources) {\n    return sources.find(source => this.isSourceSupported(source));\n  }\n\n  /**\n   * Returns whether the passed string is a base64 string or not.\n   * @param {string} str Base64 audio string\n   * @return {boolean}\n   */\n  isBase64(str) {\n    return (/^data:[^;]+;base64,/).test(str);\n  }\n\n  /**\n   * Returns true if the platform is mobile.\n   * @return {boolean}\n   * @private\n   */\n  _isMobile() {\n    if (!this._navigator) {\n      return false;\n    }\n\n    return (/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i).test(this._userAgent);\n  }\n\n  /**\n   * Returns true if the platform is touch supported.\n   * @return {boolean}\n   * @private\n   */\n  _isTouch() {\n    return typeof window !== 'undefined' && (Boolean(('ontouchend' in window) ||\n      (this._navigator && this._navigator.maxTouchPoints > 0) ||\n      (this._navigator && this._navigator.msMaxTouchPoints > 0)));\n  }\n\n  /**\n   * Returns true if the user agent is IE.\n   * @return {boolean}\n   */\n  isIE() {\n    return Boolean(this._userAgent && (/MSIE |Trident\\//).test(this._userAgent));\n  }\n\n  /**\n   * Destroys the passed audio node.\n   * @param {Audio} audio The HTML5 audio element.\n   */\n  destroyHtml5Audio(audio) {\n    audio.pause();\n    this.isIE() && (audio.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');\n    audio.onerror = null;\n    audio.onend = null;\n    audio.canplaythrough = null;\n  }\n}\n\nexport default new Utility();\n\n","/**\n * Enum to represent the download status of audio resource.\n * @enum {string}\n */\nconst DownloadStatus = {\n  Success: 'success',\n  Failure: 'error'\n};\n\nexport default DownloadStatus;\n","import BufferLoader   from './BufferLoader';\nimport MediaLoader    from './MediaLoader';\nimport emitter        from './Emitter';\nimport Queue          from './Queue';\nimport utility        from './Utility';\nimport Sound          from './Sound';\nimport DownloadStatus from './DownloadStatus';\n\n/**\n * Enum that represents the different type of errors thrown by Engine and Buzzes.\n * @enum {string}\n */\nconst ErrorType = {\n  NoAudio: 'no-audio',\n  LoadError: 'load',\n  PlayError: 'play',\n  EngineError: 'engine'\n};\n\n/**\n * Represents the different states of the audio engine.\n * @enum {string}\n */\nconst EngineState = {\n  NotReady: 'notready',\n  Ready: 'ready',\n  Suspending: 'suspending',\n  Suspended: 'suspended',\n  Resuming: 'resuming',\n  Destroying: 'destroying',\n  Done: 'done',\n  NoAudio: 'no-audio'\n};\n\n/**\n * Enum that represents the different events by engine.\n * @enum {string}\n */\nconst EngineEvents = {\n  Init: 'init',\n  Volume: 'volume',\n  Mute: 'mute',\n  Stop: 'stop',\n  Suspend: 'suspend',\n  Resume: 'resume',\n  Error: 'error',\n  Done: 'done'\n};\n\n/**\n * Array of event names.\n * @type {string[]}\n */\nconst userInputEventNames = [\n  'click',\n  'contextmenu',\n  'auxclick',\n  'dblclick',\n  'mousedown',\n  'mouseup',\n  'pointerup',\n  'touchend',\n  'keydown',\n  'keyup'\n];\n\n/**\n * The audio engine that orchestrates all the sounds.\n * @class\n */\nclass Engine {\n\n  /**\n   * Unique id of the engine.\n   * @type {number}\n   * @private\n   */\n  _id = utility.id();\n\n  /**\n   * Represents whether the audio engine is currently muted or not.\n   * @type {boolean}\n   * @private\n   */\n  _muted = false;\n\n  /**\n   * Represents the global volume.\n   * @type {number}\n   * @private\n   */\n  _volume = 1.0;\n\n  /**\n   * Maximum number of HTML5 audio objects allowed for a url.\n   * @type {number}\n   * @private\n   */\n  _maxNodesPerSource = 10;\n\n  /**\n   * The inactive sounds clean-up period.\n   * @type {number}\n   * @private\n   */\n  _cleanUpInterval = 5;\n\n  /**\n   * Inactive time of sound/HTML5 audio.\n   * @type {number}\n   * @private\n   */\n  _inactiveTime = 2;\n\n  /**\n   * Auto-enables audio in first user interaction.\n   * @type {boolean}\n   * @private\n   */\n  _autoEnable = true;\n\n  /**\n   * The clean-up interval id.\n   * @type {number|null}\n   * @private\n   */\n  _intervalId = null;\n\n  /**\n   * True if Web Audio API is available.\n   * @type {boolean}\n   * @private\n   */\n  _isAudioAvailable = false;\n\n  /**\n   * Represents the current state of the engine.\n   * @type {EngineState}\n   * @private\n   */\n  _state = EngineState.NotReady;\n\n  /**\n   * The Web Audio API's audio context.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * The master gain node.\n   * @type {GainNode}\n   * @private\n   */\n  _gainNode = null;\n\n  /**\n   * The action queue.\n   * @type {Queue}\n   * @private\n   */\n  _queue = null;\n\n  /**\n   * Array of buzzes.\n   * @type {Array<Buzz>}\n   * @private\n   */\n  _buzzesArray = [];\n\n  /**\n   * Array of sounds created directly by engine.\n   * @type {Array<Sound>}\n   * @private\n   */\n  _soundsArray = [];\n\n  /**\n   * Loader - the component that loads audio buffers with audio data.\n   * @type {BufferLoader}\n   * @private\n   */\n  _bufferLoader = null;\n\n  /**\n   * MediaLoader - the component that loads HTML5 audio nodes with audio.\n   * @type {MediaLoader}\n   * @private\n   */\n  _mediaLoader = null;\n\n  /**\n   * Registry of audio sources, sprites with short-hand notations.\n   * @type {object}\n   * @private\n   */\n  _sourceRegistry = {};\n\n  /**\n   * Instantiates the action queue.\n   * @constructor\n   */\n  constructor() {\n    this._queue = new Queue();\n    this._resumeAndRemoveListeners = this._resumeAndRemoveListeners.bind(this);\n    this.free = this.free.bind(this);\n  }\n\n  /**\n   * Instantiate the audio context and other dependencies.\n   * @param {object} [args] Input parameters object.\n   * @param {number} [args.volume = 1.0] The global volume of the sound engine.\n   * @param {boolean} [args.muted = false] Stay muted initially or not.\n   * @param {number} [args.maxNodesPerSource = 10] Maximum number of HTML5 audio objects allowed for a url.\n   * @param {number} [args.cleanUpInterval = 5] The sounds garbage collection interval period in minutes.\n   * @param {number} [args.inactiveTime = 2] The period after which sound/HTML5 audio node is marked as inactive.\n   * @param {boolean} [args.autoEnable = true] Auto-enables audio in first user interaction.\n   * @param {object} [args.src] The audio sources.\n   * @param {boolean} [args.preload = true] True to preload audio sources.\n   * @param {function} [args.progress] The function that's called to notify the progress of resources loaded.\n   * @param {function} [args.oninit] Event-handler for the \"init\" event.\n   * @param {function} [args.onstop] Event-handler for the \"stop\" event.\n   * @param {function} [args.onmute] Event-handler for the \"mute\" event.\n   * @param {function} [args.onvolume] Event-handler for the \"volume\" event.\n   * @param {function} [args.onsuspend] Event-handler for the \"suspend\" event.\n   * @param {function} [args.onresume] Event-handler for the \"resume\" event.\n   * @param {function} [args.onerror] Event-handler for the \"error\" event.\n   * @param {function} [args.ondone] Event-handler for the \"done\" event.\n   * @return {Engine}\n   */\n  setup(args) {\n    // If the setup is already done return.\n    if (this._state !== EngineState.NotReady) {\n      return this;\n    }\n\n    this._context = utility.getContext();\n\n    // Determine the audio stuff available in the current platform and set the flags accordingly.\n    this._isAudioAvailable = Boolean(this._context);\n\n    // If no Web Audio and HTML5 audio is available fire an error event.\n    if (!this._isAudioAvailable) {\n      this._state = EngineState.NoAudio;\n      this._fire(EngineEvents.Error, { type: ErrorType.NoAudio, error: 'Web Audio API is not available' });\n      return this;\n    }\n\n    // Read the input parameters from the options.\n    const {\n      volume,\n      muted,\n      maxNodesPerSource,\n      cleanUpInterval,\n      inactiveTime,\n      autoEnable,\n      src,\n      preload = true,\n      progress,\n      oninit,\n      onstop,\n      onmute,\n      onvolume,\n      onsuspend,\n      onresume,\n      onerror,\n      ondone\n    } = args || {};\n\n    // Set the properties from the read parameters.\n    typeof volume === 'number' && volume >= 0 && volume <= 1.0 && (this._volume = volume);\n    typeof muted === 'boolean' && (this._muted = muted);\n    typeof maxNodesPerSource === 'number' && (this._maxNodesPerSource = maxNodesPerSource);\n    typeof cleanUpInterval === 'number' && (this._cleanUpInterval = cleanUpInterval);\n    typeof inactiveTime === 'number' && (this._inactiveTime = inactiveTime);\n    typeof autoEnable === 'boolean' && (this._autoEnable = autoEnable);\n    typeof oninit === 'function' && this.on(EngineEvents.Init, oninit);\n    typeof onstop === 'function' && this.on(EngineEvents.Stop, onstop);\n    typeof onmute === 'function' && this.on(EngineEvents.Mute, onmute);\n    typeof onvolume === 'function' && this.on(EngineEvents.Volume, onvolume);\n    typeof onsuspend === 'function' && this.on(EngineEvents.Suspend, onsuspend);\n    typeof onresume === 'function' && this.on(EngineEvents.Resume, onresume);\n    typeof onerror === 'function' && this.on(EngineEvents.Error, onerror);\n    typeof ondone === 'function' && this.on(EngineEvents.Done, ondone);\n\n    // Create the buffer loader.\n    this._bufferLoader = new BufferLoader(this._context);\n\n    // Create the media loader.\n    this._mediaLoader = new MediaLoader(this._maxNodesPerSource, this._inactiveTime, (x) => {\n      this._freeSounds();\n      this._buzzesArray.forEach(buzz => buzz.getCompatibleSource() === x && buzz.free());\n    });\n\n    // Auto-enable audio in first user interaction.\n    // https://developers.google.com/web/updates/2018/11/web-audio-autoplay#moving-forward\n    if (this._autoEnable && this._context.state === 'suspended') {\n      userInputEventNames.forEach(eventName => document.addEventListener(eventName, this._resumeAndRemoveListeners));\n    }\n\n    // Create the audio graph.\n    this._gainNode = this._context.createGain();\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : this._volume, this._context.currentTime);\n    this._gainNode.connect(this._context.destination);\n\n    this._intervalId = window.setInterval(this.free, this._cleanUpInterval * 60 * 1000);\n\n    this._state = this._context.state !== 'suspended' ? EngineState.Ready : EngineState.Suspended;\n\n    if (typeof src === 'object') {\n      Object.keys(src).forEach(x => this.register(src[x], x));\n\n      if (preload) {\n        const getCompatibleSrc = (sources) => {\n          return sources.map(x => {\n            let s = [], f = [];\n\n            if (typeof x === 'string') {\n              s = [x];\n            } else if (Array.isArray(x)) {\n              s = x;\n            } else if (typeof x === 'object') {\n              const { url, format = [] } = x;\n\n              if (typeof url === 'string') {\n                s = [url];\n              } else if (Array.isArray(url)) {\n                s = url;\n              }\n\n              f = format;\n            }\n\n            return this._getCompatibleSource(s, f);\n          });\n        };\n\n        const bufferUrls = getCompatibleSrc(Object.values(src).filter(x => !x.stream));\n        const mediaUrls = getCompatibleSrc(Object.values(src).filter(x => x.stream));\n\n        Promise.all([this.load(bufferUrls, progress), this.loadMedia(mediaUrls)])\n          .then(result => this._fire(EngineEvents.Init, result));\n      } else {\n        this._fire(EngineEvents.Init);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Plays the sound belongs to the passed id or creates a new sound and play it.\n   * @param {number|string|Array<string>|object} idOrSoundArgs The sound id or new sound arguments.\n   * @param {number} [idOrSoundArgs.id] The unique id of the sound.\n   * @param {string|Array<string>} [idOrSoundArgs.src] Single or array of audio urls/base64 strings.\n   * @param {string|string[]} [idOrSoundArgs.format] The file format(s) of the passed audio source(s).\n   * @param {object} [idOrSoundArgs.sprite] The sprite definition.\n   * @param {string} [idOrSoundArgs.sound] The sound defined in sprite to play.\n   * @param {boolean} [idOrSoundArgs.stream = false] True to use HTML5 audio node for playing sound.\n   * @param {number} [idOrSoundArgs.volume = 1.0] The initial volume of the sound. Should be from 0.0 to 1.0.\n   * @param {number} [idOrSoundArgs.rate = 1] The initial playback rate of the sound. Should be from 0.5 to 5.0.\n   * @param {boolean} [idOrSoundArgs.loop = false] True to play the sound repeatedly.\n   * @param {boolean} [idOrSoundArgs.muted = false] True to be muted initially.\n   * @param {function} [idOrSoundArgs.loadCallback] The callback that will be called when the underlying HTML5 audio node is loaded.\n   * @param {function} [idOrSoundArgs.playEndCallback] The callback that will be invoked after the play ends.\n   * @param {function} [idOrSoundArgs.destroyCallback] The callback that will be invoked after destroyed.\n   * @param {function} [idOrSoundArgs.fadeEndCallback] The callback that will be invoked the fade is completed.\n   * @param {function} [idOrSoundArgs.audioErrorCallback] The callback that will be invoked when there is error in HTML5 audio node.\n   * @return {Engine|number}\n   */\n  play(idOrSoundArgs) {\n    // If id is passed then get the sound from the engine and play it.\n    if (typeof idOrSoundArgs === 'number') {\n      const sound = this.sound(idOrSoundArgs);\n      sound && sound.play();\n      return this;\n    }\n\n    let audioSrc = [],\n      audioFormat = [],\n      audioSprite = null,\n      spriteSound = null,\n      soundArgs = {};\n\n    if (typeof idOrSoundArgs === 'string') {\n      if (idOrSoundArgs.startsWith('#')) {\n        const parts = idOrSoundArgs.split('.'),\n          key = parts[0].substring(1);\n\n        spriteSound = parts[1];\n\n        ({ audioSrc, audioFormat, audioSprite } = this._getSourceInfo(key));\n      } else {\n        audioSrc = [idOrSoundArgs];\n      }\n    } else if (Array.isArray(idOrSoundArgs)) {\n      audioSrc = idOrSoundArgs;\n    } else if (typeof idOrSoundArgs === 'object') {\n      const {\n        id,\n        src,\n        format,\n        sprite,\n        sound,\n        stream,\n        volume,\n        rate,\n        loop,\n        muted,\n        loadCallback,\n        playEndCallback,\n        destroyCallback,\n        fadeEndCallback,\n        audioErrorCallback\n      } = idOrSoundArgs;\n\n      if (typeof src === 'string') {\n        if (src.startsWith('#')) {\n          const parts = src.split('.'),\n            key = parts[0].substring(1);\n\n          ({ audioSrc, audioFormat, audioSprite } = this._getSourceInfo(key));\n        } else {\n          audioSrc = [src];\n        }\n      } else if (Array.isArray(src)) {\n        audioSrc = src;\n      }\n\n      if (Array.isArray(format)) {\n        audioFormat = format;\n      } else if (typeof format === 'string' && format) {\n        audioFormat = [format];\n      }\n\n      typeof id === 'number' && (soundArgs.id = id);\n      typeof sprite === 'object' && (audioSprite = sprite);\n      typeof sound === 'string' && (spriteSound = sound);\n      typeof stream === 'boolean' && (soundArgs.stream = stream);\n      typeof volume === 'number' && volume >= 0 && volume <= 1.0 && (soundArgs.volume = volume);\n      typeof rate === 'number' && rate >= 0.5 && rate <= 5 && (soundArgs.rate = rate);\n      typeof muted === 'boolean' && (soundArgs.muted = muted);\n      typeof loop === 'boolean' && (soundArgs.loop = loop);\n      typeof loadCallback === 'function' && (soundArgs.loadCallback = loadCallback);\n      typeof playEndCallback === 'function' && (soundArgs.playEndCallback = playEndCallback);\n      typeof destroyCallback === 'function' && (soundArgs.destroyCallback = destroyCallback);\n      typeof fadeEndCallback === 'function' && (soundArgs.fadeEndCallback = fadeEndCallback);\n      typeof audioErrorCallback === 'function' && (soundArgs.audioErrorCallback = audioErrorCallback);\n    }\n\n    if (!audioSrc.length) {\n      throw new Error('You should pass the source for the audio.');\n    }\n\n    this.setup();\n\n    const {\n      stream,\n      loadCallback,\n      audioErrorCallback,\n      destroyCallback\n    } = soundArgs;\n\n    if (!this.isAudioAvailable()) {\n      audioErrorCallback && audioErrorCallback({ type: ErrorType.NoAudio, error: 'Web Audio is un-available' });\n      return this;\n    }\n\n    const compatibleSrc = this._getCompatibleSource(audioSrc, audioFormat);\n\n    soundArgs.destroyCallback = (sound) => {\n      this._removeSound(sound);\n      this.releaseForSound(compatibleSrc, this._id, sound.id());\n      destroyCallback && destroyCallback(sound);\n    };\n\n    if (typeof spriteSound === 'string' && audioSprite && audioSprite.hasOwnProperty(spriteSound)) {\n      const positions = audioSprite[spriteSound];\n      soundArgs.startPos = positions[0];\n      soundArgs.endPos = positions[1];\n    }\n\n    const sound = new Sound(soundArgs);\n    sound._gain().connect(this._gainNode);\n    this._soundsArray.push(sound);\n\n    const load$ = stream ? this.allocateForGroup(compatibleSrc, this._id) : this.load(compatibleSrc);\n\n    load$.then(downloadResult => {\n      if (downloadResult.status === DownloadStatus.Success) {\n        sound.source(stream ? this.allocateForSound(compatibleSrc, this._id, sound.id()) : downloadResult.value);\n        this._play(sound);\n      }\n\n      loadCallback && loadCallback(downloadResult, sound);\n    });\n\n    return sound.id();\n  }\n\n  /**\n   * Pauses the sound.\n   * @param {number} id The sound id.\n   * @return {Engine}\n   */\n  pause(id) {\n    const sound = this.sound(id);\n    sound && sound.pause();\n    return this;\n  }\n\n  /**\n   * Stops all the currently playing sounds.\n   * @param {number} [id] The sound id.\n   * @return {Engine}\n   */\n  stop(id) {\n    if (typeof id !== 'undefined') {\n      const sound = this.sound(id);\n      sound && sound.stop();\n      return this;\n    }\n\n    // Stop all the sounds.\n    this.buzzes().forEach(buzz => buzz.stop());\n    this.sounds().forEach(sound => sound.stop());\n\n    // Fire the \"stop\" event.\n    this._fire(EngineEvents.Stop);\n\n    return this;\n  }\n\n  /**\n   * Mutes the engine or the passed sound.\n   * @param {number} [id] The sound id.\n   * @return {Engine}\n   */\n  mute(id) {\n    if (typeof id !== 'undefined') {\n      const sound = this.sound(id);\n      sound && sound.mute();\n      return this;\n    }\n\n    // If the engine is already muted return.\n    if (this._muted) {\n      return this;\n    }\n\n    // Set the value of gain node to 0.\n    this._gainNode.gain.setValueAtTime(0, this._context.currentTime);\n\n    // Set the muted property true.\n    this._muted = true;\n\n    // Fire the \"mute\" event.\n    this._fire(EngineEvents.Mute, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Un-mutes the engine or the passed sound.\n   * @param {number} [id] The sound id.\n   * @return {Engine}\n   */\n  unmute(id) {\n    if (typeof id !== 'undefined') {\n      const sound = this.sound(id);\n      sound && sound.unmute();\n      return this;\n    }\n\n    // If the engine is not muted return.\n    if (!this._muted) {\n      return this;\n    }\n\n    // Reset the gain node's value back to volume.\n    this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime);\n\n    // Set the muted property to false.\n    this._muted = false;\n\n    // Fire the \"mute\" event.\n    this._fire(EngineEvents.Mute, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the volume for the audio engine or the passed sound.\n   * @param {number} [vol] Should be within 0.0 to 1.0.\n   * @param {number} [id] The sound id.\n   * @return {Engine|number}\n   */\n  volume(vol, id) {\n    if (typeof id !== 'undefined') {\n      const sound = this.sound(id);\n\n      if (sound) {\n        if (vol === undefined) {\n          return sound.volume();\n        }\n\n        sound.volume(vol);\n        return this;\n      }\n    }\n\n    // If no parameter is passed then return the current volume.\n    if (vol === undefined) {\n      return this._volume;\n    }\n\n    // If passed volume is not an acceptable value return.\n    if (typeof vol !== 'number' || vol < 0 || vol > 1.0) {\n      return this;\n    }\n\n    // Set the gain's value to the passed volume.\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : vol, this._context.currentTime);\n\n    // Set the volume to the property.\n    this._volume = vol;\n\n    // Fire the \"volume\" event.\n    this._fire(EngineEvents.Volume, this._volume);\n\n    return this;\n  }\n\n  /**\n   * Fades the sound volume to the passed value in the passed duration.\n   * @param {number} id The sound id.\n   * @param {number} to The destination volume.\n   * @param {number} duration The period of fade.\n   * @param {string} [type = linear] The fade type (linear or exponential).\n   * @return {Engine}\n   */\n  fade(id, to, duration, type = 'linear') {\n    const sound = this.sound(id);\n    sound && sound.fade(to, duration, type);\n    return this;\n  }\n\n  /**\n   * Stops the current running fade.\n   * @param {number} id The sound id.\n   * @return {Engine}\n   */\n  fadeStop(id) {\n    const sound = this.sound(id);\n    sound && sound.fadeStop();\n    return this;\n  }\n\n  /**\n   * Gets/sets the playback rate.\n   * @param {number} id The sound id.\n   * @param {number} [rate] The playback rate. Should be from 0.5 to 5.\n   * @return {Engine|number}\n   */\n  rate(id, rate) {\n    const sound = this.sound(id);\n\n    if (sound) {\n      if (typeof rate === 'undefined') {\n        return sound.rate();\n      }\n\n      sound.rate(rate);\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the seek position.\n   * @param {number} id The sound id.\n   * @param {number} [seek] The seek position.\n   * @return {Engine|number}\n   */\n  seek(id, seek) {\n    const sound = this.sound(id);\n\n    if (sound) {\n      if (typeof seek === 'undefined') {\n        return sound.seek();\n      }\n\n      sound.seek(seek);\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the loop parameter of the sound.\n   * @param {number} id The sound id.\n   * @param {boolean} [loop] True to loop the sound.\n   * @return {Engine/boolean}\n   */\n  loop(id, loop) {\n    const sound = this.sound(id);\n\n    if (sound) {\n      if (typeof loop === 'undefined') {\n        return sound.loop();\n      }\n\n      sound.loop(loop);\n    }\n\n    return this;\n  }\n\n  /**\n   * Destroys the passed sound.\n   * @param {number} id The sound id.\n   * @return {Engine}\n   */\n  destroy(id) {\n    const sound = this.sound(id);\n    sound && sound.destroy();\n    return this;\n  }\n\n  /**\n   * Stops all the playing sounds and suspends the audio context immediately.\n   * @return {Engine}\n   */\n  suspend() {\n    // If the context is resuming then suspend after resumed.\n    if (this._state === EngineState.Resuming) {\n      this._queue.add('after-resume', 'suspend', () => this.suspend());\n      return this;\n    }\n\n    // If the state is not ready return.\n    if (this._state !== EngineState.Ready) {\n      return this;\n    }\n\n    // Stop all the playing sounds.\n    this.stop();\n\n    // Set the state to suspending.\n    this._state = EngineState.Suspending;\n\n    // Suspend the Audio Context.\n    this._context.suspend().then(() => {\n      this._state = EngineState.Suspended;\n      this._queue.run('after-suspend');\n      this._fire(EngineEvents.Suspend);\n    });\n\n    return this;\n  }\n\n  /**\n   * Resumes the audio context from the suspended mode.\n   * @return {Engine}\n   */\n  resume() {\n    // If the context is suspending then resume after suspended.\n    if (this._state === EngineState.Suspending) {\n      this._queue.add('after-suspend', 'resume', () => this.resume());\n      return this;\n    }\n\n    if (this._state !== EngineState.Suspended) {\n      return this;\n    }\n\n    this._state = EngineState.Resuming;\n\n    this._context.resume().then(() => {\n      this._state = EngineState.Ready;\n      this._queue.run('after-resume');\n      this._fire(EngineEvents.Resume);\n    });\n\n    return this;\n  }\n\n  /**\n   * Shuts down the engine.\n   * @return {Engine}\n   */\n  terminate() {\n    if (this._state === EngineState.Done || this._state === EngineState.Destroying) {\n      return this;\n    }\n\n    const cleanUp = () => {\n      // Un-listen from user input events.\n      userInputEventNames.forEach(eventName => document.addEventListener(eventName, this._resumeAndRemoveListeners));\n\n      // Stop the timer.\n      this._intervalId && window.clearInterval(this._intervalId);\n      this._intervalId = null;\n\n      // Destroy all the buzzes.\n      this._buzzesArray.forEach(buzz => buzz.destroy());\n\n      // Destroy all sounds.\n      this._soundsArray.forEach(sound => sound.destroy());\n\n      // Clear the cache and remove the loader.\n      if (this._bufferLoader) {\n        this._bufferLoader.dispose();\n        this._bufferLoader = null;\n      }\n\n      // Dispose the MediaLoader.\n      if (this._mediaLoader) {\n        this._mediaLoader.dispose();\n        this._mediaLoader = null;\n      }\n\n      this._buzzesArray = [];\n      this._soundsArray = [];\n      this._context = null;\n      this._queue.clear();\n      this._queue = null;\n      this._state = EngineState.Done;\n\n      // Fire the \"done\" event.\n      this._fire(EngineEvents.Done);\n\n      emitter.clear(this._id);\n    };\n\n    // Close the context.\n    if (this._context) {\n      if (this._state === EngineState.Suspending) {\n        this._queue.remove('after-suspend');\n        this._queue.add('after-suspend', 'destroy', () => this.terminate());\n        return this;\n      } else if (this._state === EngineState.Resuming) {\n        this._queue.remove('after-resume');\n        this._queue.add('after-resume', 'destroy', () => this.terminate());\n        return this;\n      }\n\n      this._state = EngineState.Destroying;\n      this._context && this._context.close().then(() => cleanUp());\n    } else {\n      this._state = EngineState.Destroying;\n      cleanUp();\n    }\n\n    return this;\n  }\n\n  /**\n   * Assigns a short-hand key for the audio source.\n   * @param {string|Array<string>|object} src The audio source.\n   * @param {string|Array<string>} src.url The audio source.\n   * @param {string|Array<string>} src.format The audio formats.\n   * @param {object} src.sprite The sprite definition.\n   * @param {string} key The shorthand key to access it.\n   * @return {Engine}\n   */\n  register(src, key) {\n    if (this._sourceRegistry.hasOwnProperty(key)) {\n      return this;\n    }\n\n    this._sourceRegistry[key] = src;\n\n    return this;\n  }\n\n  /**\n   * Removes the assigned key for the audio source.\n   * @param {string} src The audio source.\n   * @param {string} key The shorthand key to access it.\n   * @return {Engine}\n   */\n  unregister(src, key) {\n    delete this._sourceRegistry[key];\n    return this;\n  }\n\n  /**\n   * Returns the source assigned for the key.\n   * @param {string} key The shorthand key.\n   * @return {*}\n   */\n  getSource(key) {\n    return this._sourceRegistry[key];\n  }\n\n  /**\n   * Loads single or multiple audio resources into audio buffers and returns them.\n   * @param {string|string[]} urls Single or array of audio urls.\n   * @param {function} [progressCallback] The callback that is called to intimate the percentage downloaded.\n   * @return {Promise}\n   */\n  load(urls, progressCallback) {\n    return this._bufferLoader.load(urls, progressCallback);\n  }\n\n  /**\n   * Loads HTML5 audio nodes for the passed urls.\n   * @param {string|string[]} urls Single or array of audio urls.\n   * @return {Promise<DownloadResult|Array<DownloadResult>>}\n   */\n  loadMedia(urls) {\n    return this._mediaLoader.load(urls);\n  }\n\n  /**\n   * Stores the buzz in the internal collection.\n   * @param {Buzz} buzz The newly created buzz.\n   * @return {Engine}\n   */\n  add(buzz) {\n    if (this._buzzesArray.indexOf(buzz) > -1) {\n      return this;\n    }\n\n    this._buzzesArray.push(buzz);\n\n    return this;\n  }\n\n  /**\n   * Removes the stored buzz from the internal collection.\n   * @param {Buzz} buzz The buzz.\n   * @return {Engine}\n   */\n  remove(buzz) {\n    this._buzzesArray.splice(this._buzzesArray.indexOf(buzz), 1);\n    return this;\n  }\n\n  /**\n   * Loads audio node for group.\n   * @param {string} url The audio file url.\n   * @param {number} groupId The group id.\n   * @return {Promise<DownloadResult>}\n   */\n  allocateForGroup(url, groupId) {\n    return this._mediaLoader.allocateForGroup(url, groupId);\n  }\n\n  /**\n   * Allocates an audio node for sound and returns it.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The buzz id.\n   * @param {number} soundId The sound id.\n   * @return {Audio}\n   */\n  allocateForSound(src, groupId, soundId) {\n    return this._mediaLoader.allocateForSound(src, groupId, soundId);\n  }\n\n  /**\n   * Unloads single or multiple loaded audio buffers from cache.\n   * @param {string|string[]} [urls] Single or array of audio urls.\n   * @return {Engine}\n   */\n  unload(urls) {\n    if (urls) {\n      this._bufferLoader.unload(urls);\n      return this;\n    }\n\n    this._bufferLoader.unload();\n\n    return this;\n  }\n\n  /**\n   * Releases audio nodes allocated for the passed urls.\n   * @param {string|string[]} [urls] Single or array of audio urls.\n   * @return {Engine}\n   */\n  unloadMedia(urls) {\n    if (urls) {\n      this._mediaLoader.unload(urls);\n      return this;\n    }\n\n    this._mediaLoader.unload();\n\n    return this;\n  }\n\n  /**\n   * Releases the allocated audio nodes for the group.\n   * @param {string} url The audio file url.\n   * @param {number} groupId The group id.\n   * @return {Engine}\n   */\n  releaseForGroup(url, groupId) {\n    this._mediaLoader.releaseForGroup(url, groupId);\n    return this;\n  }\n\n  /**\n   * Destroys the audio node reserved for sound.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The buzz id.\n   * @param {number} soundId The sound id.\n   */\n  releaseForSound(src, groupId, soundId) {\n    this._mediaLoader.releaseForSound(src, groupId, soundId);\n  }\n\n  /**\n   * Returns if there are free audio nodes available for a group.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The group id.\n   * @return {boolean}\n   */\n  hasFreeNodes(src, groupId) {\n    return this._mediaLoader.hasFreeNodes(src, groupId);\n  }\n\n  /**\n   * Subscribes to an event.\n   * @param {string} eventName Name of the event.\n   * @param {function} handler The event-handler function.\n   * @param {boolean} [once = false] Is it one-time subscription or not.\n   * @return {Engine}\n   */\n  on(eventName, handler, once = false) {\n    emitter.on(this._id, eventName, handler, once);\n    return this;\n  }\n\n  /**\n   * Un-subscribes from an event.\n   * @param {string} eventName The event name.\n   * @param {function} [handler] The handler function.\n   * @return {Engine}\n   */\n  off(eventName, handler) {\n    emitter.off(this._id, eventName, handler);\n    return this;\n  }\n\n  /**\n   * Removes the inactive sounds.\n   * @return {Engine}\n   */\n  free() {\n    this._freeSounds();\n    this._buzzesArray.forEach(buzz => buzz.free());\n    this._mediaLoader.cleanUp();\n    return this;\n  }\n\n  /**\n   * Returns whether the engine is currently muted or not.\n   * @return {boolean}\n   */\n  muted() {\n    return this._muted;\n  }\n\n  /**\n   * Returns the state of the engine.\n   * @return {EngineState}\n   */\n  state() {\n    return this._state;\n  }\n\n  /**\n   * Returns the created audio context.\n   * @return {AudioContext}\n   */\n  context() {\n    return this._context;\n  }\n\n  /**\n   * Returns the master gain node.\n   * @return {GainNode}\n   */\n  masterGain() {\n    return this._gainNode;\n  }\n\n  /**\n   * Returns true if Web Audio API is available.\n   * @return {boolean}\n   */\n  isAudioAvailable() {\n    return this._isAudioAvailable;\n  }\n\n  /**\n   * Returns the buffer loader.\n   * @return {BufferLoader}\n   */\n  bufferLoader() {\n    return this._bufferLoader;\n  }\n\n  /**\n   * Returns the HTML5 media loader.\n   * @return {MediaLoader}\n   */\n  mediaLoader() {\n    return this._mediaLoader;\n  }\n\n  /**\n   * Returns the buzz for the passed id.\n   * @param {number} id The buzz id.\n   * @return {Buzz}\n   */\n  buzz(id) {\n    return this._buzzesArray.find(x => x.id() === id);\n  }\n\n  /**\n   * Returns all the buzzes.\n   * @return {Array<Buzz>}\n   */\n  buzzes() {\n    return this._buzzesArray;\n  }\n\n  /**\n   * Returns the sound for the passed id.\n   * @param {number} id The sound id.\n   * @return {Sound}\n   */\n  sound(id) {\n    return this._soundsArray.find(x => x.id() === id);\n  }\n\n  /**\n   * Returns all the sounds.\n   * @return {Array<Sound>}\n   */\n  sounds() {\n    return this._soundsArray;\n  }\n\n  /**\n   * Returns in active time.\n   * @return {number}\n   */\n  inactiveTime() {\n    return this._inactiveTime;\n  }\n\n  /**\n   * Returns source, format and sprite from the assigned key.\n   * @param {string} key The source key.\n   * @return {object}\n   * @private\n   */\n  _getSourceInfo(key) {\n    const src = this.getSource(key);\n    const sourceInfo = {\n      audioSrc: [],\n      audioFormat: [],\n      audioSprite: null\n    };\n\n    if (typeof src === 'string') {\n      sourceInfo.audioSrc = [src];\n    } else if (Array.isArray(src)) {\n      sourceInfo.audioSrc = src;\n    } else if (typeof src === 'object') {\n      const {\n        url,\n        format,\n        sprite\n      } = src;\n\n      if (typeof url === 'string') {\n        sourceInfo.audioSrc = [url];\n      } else if (Array.isArray(url)) {\n        sourceInfo.audioSrc = url;\n      }\n\n      if (Array.isArray(format)) {\n        sourceInfo.format = format;\n      } else if (typeof format === 'string' && format) {\n        sourceInfo.format = [format];\n      }\n\n      typeof sprite === 'object' && (sourceInfo.audioSprite = sprite);\n    }\n\n    return sourceInfo;\n  }\n\n  /**\n   * Fires an event of engine.\n   * @param {string} eventName The event name.\n   * @param {...*} args The arguments that to be passed to handler.\n   * @return {Engine}\n   * @private\n   */\n  _fire(eventName, ...args) {\n    emitter.fire(this._id, eventName, ...args, this);\n    return this;\n  }\n\n  /**\n   * Resume the context and un-listen from user input events.\n   * @private\n   */\n  _resumeAndRemoveListeners() {\n    this.resume();\n    userInputEventNames.forEach(eventName => document.addEventListener(eventName, this._resumeAndRemoveListeners));\n  }\n\n  /**\n   * Removes the passed sound from the array.\n   * @param {number|Sound} sound The sound.\n   * @private\n   */\n  _removeSound(sound) {\n    if (typeof sound === 'number') {\n      this._soundsArray = this._soundsArray.filter(x => x.id() !== sound);\n      return;\n    }\n\n    this._soundsArray.splice(this._soundsArray.indexOf(sound), 1);\n  }\n\n  /**\n   * Returns the first compatible source based on the passed sources and the format.\n   * @param {Array<string>} src The array of audio sources.\n   * @param {Array<string>} format The array of audio formats.\n   * @private\n   * @return {string}\n   */\n  _getCompatibleSource(src, format) {\n    // If the user has passed \"format\", check if it is supported or else retrieve the first supported source from the array.\n    return format.length ?\n      src[format.indexOf(utility.getSupportedFormat(format))] :\n      utility.getSupportedSource(src);\n  }\n\n  /**\n   * Checks the engine state and plays the passed sound.\n   * @param {Sound} sound The sound.\n   * @private\n   */\n  _play(sound) {\n    const { audioErrorCallback } = sound;\n\n    if (this._state === EngineState.Destroying || this._state === EngineState.Done) {\n      audioErrorCallback && audioErrorCallback({ type: ErrorType.PlayError, error: 'The engine is stopping/stopped' }, sound);\n      return;\n    }\n\n    if (this._state === EngineState.NoAudio) {\n      audioErrorCallback && audioErrorCallback({ type: ErrorType.NoAudio, error: 'Web Audio is un-available' }, sound);\n      return;\n    }\n\n    if ([EngineState.Suspending, EngineState.Suspended, EngineState.Resuming].indexOf(this._state) > -1) {\n      this._queue.add('after-resume', `sound-${sound.id()}`, () => sound.play());\n      this._state !== EngineState.Resuming && this.resume();\n      return;\n    }\n\n    sound.play();\n  }\n\n  /**\n   * Destroys inactive sounds.\n   * @private\n   */\n  _freeSounds() {\n    const now = new Date();\n\n    this._soundsArray = this._soundsArray.filter(sound => {\n      const inactiveDurationInSeconds = (now - sound.lastPlayed()) / 1000;\n\n      if (sound.isPersistent() ||\n        sound.isPlaying() ||\n        sound.isPaused() ||\n        inactiveDurationInSeconds < this.inactiveTime() * 60) {\n        return true;\n      }\n\n      sound.destroy();\n      return false;\n    });\n  }\n}\n\nconst engine = new Engine();\nexport { engine as default, EngineState, EngineEvents, ErrorType };\n","import DownloadStatus from './DownloadStatus';\n\n/**\n * Represents the download result of an audio.\n * @class\n */\nclass DownloadResult {\n\n  /**\n   * The url of the audio resource\n   * @type {string|null}\n   */\n  url = null;\n\n  /**\n   * AudioBuffer or Html5Audio element\n   * @type {AudioBuffer|Audio}\n   */\n  value = null;\n\n  /**\n   * Download error\n   * @type {any}\n   */\n  error = null;\n\n  /**\n   * Success or failure status of download.\n   * @type {DownloadStatus}\n   */\n  status = null;\n\n  /**\n   * @param {string|null} url The url of the audio resource\n   * @param {AudioBuffer|Audio} [value] AudioBuffer or Html5Audio element\n   * @param {*} [error] Download error\n   */\n  constructor(url, value, error) {\n    this.url = url;\n    this.value = value;\n    this.error = error || null;\n    this.status = error ? DownloadStatus.Failure : DownloadStatus.Success;\n  }\n}\n\nexport default DownloadResult;\n","/**\n * Singleton global event emitter.\n * @class\n */\nclass Emitter {\n\n  /**\n   * Dictionary that maps the objects with their events and handlers.\n   * @type {object}\n   * @private\n   */\n  _objectsEventsHandlersMap = {};\n\n  /**\n   * Subscribes to an event of the passed object.\n   * @param {number} id The unique id of the object.\n   * @param {string} eventName Name of the event\n   * @param {function} handler The event-handler function\n   * @param {boolean} [once = false] Is it one-time subscription or not?\n   * @return {Emitter}\n   */\n  on(id, eventName, handler, once = false) {\n    if (!this._hasObject(id)) {\n      this._objectsEventsHandlersMap[id] = {};\n    }\n\n    const objEvents = this._objectsEventsHandlersMap[id];\n\n    if (!objEvents.hasOwnProperty(eventName)) {\n      objEvents[eventName] = [];\n    }\n\n    objEvents[eventName].push({\n      handler: handler,\n      once: once\n    });\n\n    return this;\n  }\n\n  /**\n   * Un-subscribes from an event of the passed object.\n   * @param {number} id The unique id of the object.\n   * @param {string} eventName The event name.\n   * @param {function} [handler] The handler function.\n   * @return {Emitter}\n   */\n  off(id, eventName, handler) {\n    if (!this._hasEvent(id, eventName)) {\n      return this;\n    }\n\n    const objEvents = this._objectsEventsHandlersMap[id];\n\n    if (!handler) {\n      objEvents[eventName] = [];\n    } else {\n      objEvents[eventName] = objEvents[eventName].filter(eventSubscriber => {\n        return eventSubscriber.handler !== handler;\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Fires an event of the object passing the source and other optional arguments.\n   * @param {number} id The unique id of the object.\n   * @param {string} eventName The event name\n   * @param {...*} args The arguments that to be passed to handler\n   * @return {Emitter}\n   */\n  fire(id, eventName, ...args) {\n    if (!this._hasEvent(id, eventName)) {\n      return this;\n    }\n\n    let eventSubscribers = this._objectsEventsHandlersMap[id][eventName];\n\n    for (let i = 0; i < eventSubscribers.length; i++) {\n      let eventSubscriber = eventSubscribers[i];\n\n      setTimeout(function (subscriber) {\n        const { handler, once } = subscriber;\n\n        handler(...args);\n\n        if (once) {\n          this.off(id, eventName, handler);\n        }\n      }.bind(this, eventSubscriber), 0);\n    }\n\n    return this;\n  }\n\n  /**\n   * Clears the event handlers of the passed object.\n   * @param {number} [id] The unique id of the object.\n   * @return {Emitter}\n   */\n  clear(id) {\n    if (!id) {\n      this._objectsEventsHandlersMap = {};\n      return this;\n    }\n\n    if (this._hasObject(id)) {\n      delete this._objectsEventsHandlersMap[id];\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns true if the object is already registered.\n   * @param {number} id The object id.\n   * @return {boolean}\n   * @private\n   */\n  _hasObject(id) {\n    return this._objectsEventsHandlersMap.hasOwnProperty(id);\n  }\n\n  /**\n   * Returns true if the passed object has an entry of the passed event.\n   * @param {number} id The object id.\n   * @param {string} eventName The event name.\n   * @return {boolean}\n   * @private\n   */\n  _hasEvent(id, eventName) {\n    return this._hasObject(id) && this._objectsEventsHandlersMap[id].hasOwnProperty(eventName);\n  }\n}\n\nexport default new Emitter();\n","/**\n * Stores queue of actions that has to be run before or after specific events.\n */\nclass Queue {\n\n  _eventActions = {};\n\n  /**\n   * Queues the passed action to the event.\n   * @param {string} eventName The event name.\n   * @param {string} actionIdentifier The action identifier.\n   * @param {function} action The action function.\n   * @param {boolean} [removeAfterRun = true] Remove the action once it's run.\n   */\n  add(eventName, actionIdentifier, action, removeAfterRun = true) {\n    if (!this.hasEvent(eventName)) {\n      this._eventActions[eventName] = {};\n    }\n\n    this._eventActions[eventName][actionIdentifier] = { fn: action, removeAfterRun: removeAfterRun };\n  }\n\n  /**\n   * Returns true if there is a event exists for the passed name.\n   * @param {string} eventName The event name.\n   * @return {boolean}\n   */\n  hasEvent(eventName) {\n    return this._eventActions.hasOwnProperty(eventName);\n  }\n\n  /**\n   * Returns true if the passed action is already queued-up.\n   * @param {string} eventName The event name.\n   * @param {string} actionIdentifier The action identifier.\n   * @return {boolean}\n   */\n  hasAction(eventName, actionIdentifier) {\n    if (!this.hasEvent(eventName)) {\n      return false;\n    }\n\n    return this._eventActions[eventName].hasOwnProperty(actionIdentifier);\n  }\n\n  /**\n   * Runs all the actions queued up for the passed event.\n   * @param {string} eventName The event name.\n   * @param {string} [actionIdentifier] The action identifier.\n   */\n  run(eventName, actionIdentifier) {\n    if (!this.hasEvent(eventName)) {\n      return;\n    }\n\n    if (typeof actionIdentifier !== 'undefined') {\n      if (!this.hasAction(eventName, actionIdentifier)) {\n        return;\n      }\n\n      this._run(eventName, actionIdentifier);\n\n      return;\n    }\n\n    Object.keys(this._eventActions[eventName]).forEach(action => this._run(eventName, action));\n  }\n\n  /**\n   * Removes the event or a queued action for the event.\n   * @param {string} eventName The event name.\n   * @param {string} [actionIdentifier] The action identifier.\n   */\n  remove(eventName, actionIdentifier) {\n    if (!this._eventActions.hasOwnProperty(eventName)) {\n      return;\n    }\n\n    if (!actionIdentifier) {\n      delete this._eventActions[eventName];\n      return;\n    }\n\n    delete this._eventActions[eventName][actionIdentifier];\n  }\n\n  /**\n   * Clears all the stored events and the queued-up actions.\n   */\n  clear() {\n    this._eventActions = {};\n  }\n\n  /**\n   * Runs a single action.\n   * @param {string} eventName The event name.\n   * @param {string} actionIdentifier The action identifier.\n   * @private\n   */\n  _run(eventName, actionIdentifier) {\n    const queued = this._eventActions[eventName][actionIdentifier];\n    queued.fn();\n    queued.removeAfterRun && this.remove(eventName, actionIdentifier);\n  }\n}\n\nexport default Queue;\n","import engine      from './Engine';\nimport utility     from './Utility';\nimport workerTimer from './WorkerTimer';\n\n/**\n * Enum that represents the different states of a sound.\n * @enum {string}\n */\nconst SoundState = {\n  Ready: 'ready',\n  Playing: 'playing',\n  Paused: 'paused',\n  Destroyed: 'destroyed'\n};\n\n/**\n * Represents a sound created using Web Audio API.\n * @class\n */\nclass Sound {\n\n  /**\n   * Unique id.\n   * @type {number}\n   * @private\n   */\n  _id = -1;\n\n  /**\n   * The current volume of the sound. Should be from 0.0 to 1.0.\n   * @type {number}\n   * @private\n   */\n  _volume = 1.0;\n\n  /**\n   * The current playback speed. Should be from 0.5 to 5.\n   * @type {number}\n   * @private\n   */\n  _rate = 1;\n\n  /**\n   * True if the sound is currently muted.\n   * @type {boolean}\n   * @private\n   */\n  _muted = false;\n\n  /**\n   * True if the sound should play repeatedly.\n   * @type {boolean}\n   * @private\n   */\n  _loop = false;\n\n  /**\n   * The current state (playing, paused etc.) of the sound.\n   * @type {SoundState}\n   * @private\n   */\n  _state = SoundState.Ready;\n\n  /**\n   * Web API's audio context.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * The gain node to control the volume of the sound.\n   * @type {GainNode}\n   * @private\n   */\n  _gainNode = null;\n\n  /**\n   * True to use HTML5 audio node.\n   * @type {boolean}\n   * @private\n   */\n  _stream = false;\n\n  /**\n   * The audio buffer.\n   * @type {AudioBuffer}\n   * @private\n   */\n  _buffer = null;\n\n  /**\n   * The HTML5 Audio element.\n   * @type {Audio}\n   * @private\n   */\n  _audio = null;\n\n  /**\n   * The AudioBufferSourceNode that plays the audio buffer assigned to it.\n   * @type {AudioBufferSourceNode}\n   * @private\n   */\n  _bufferSourceNode = null;\n\n  /**\n   * Duration of the playback in seconds.\n   * @type {number}\n   * @private\n   */\n  _duration = 0;\n\n  /**\n   * The playback start position.\n   * @type {number}\n   * @private\n   */\n  _startPos = 0;\n\n  /**\n   * The playback end position.\n   * @type {number}\n   * @private\n   */\n  _endPos = 0;\n\n  /**\n   * The current position of the playback.\n   * @type {number}\n   * @private\n   */\n  _currentPos = 0;\n\n  /**\n   * The position of the playback during rate change.\n   * @type {number}\n   * @private\n   */\n  _rateSeek = 0;\n\n  /**\n   * The time at which the playback started.\n   * This property is required for getting the seek position of the playback.\n   * @type {number}\n   * @private\n   */\n  _startTime = 0;\n\n  /**\n   * The callback that will be called when the underlying HTML5 audio node is loaded.\n   * @type {function}\n   * @private\n   */\n  _loadCallback = null;\n\n  /**\n   * The callback that will be invoked after the play ends.\n   * @type {function}\n   * @private\n   */\n  _playEndCallback = null;\n\n  /**\n   * The callback that will be invoked after the sound destroyed.\n   * @type {function}\n   * @private\n   */\n  _destroyCallback = null;\n\n  /**\n   * True if the sound is currently fading.\n   * @type {boolean}\n   * @private\n   */\n  _fading = false;\n\n  /**\n   * The timer that runs function after the fading is complete.\n   * @type {number|null}\n   * @private\n   */\n  _fadeTimer = null;\n\n  /**\n   * The callback that will be invoked after the fade is completed.\n   * @type {function}\n   * @private\n   */\n  _fadeEndCallback = null;\n\n  /**\n   * The callback that will be invoked when there is error in HTML5 audio node.\n   * @type {function}\n   * @private\n   */\n  _audioErrorCallback = null;\n\n  /**\n   * Web Audio API's audio node to control media element.\n   * @type {MediaElementAudioSourceNode}\n   * @private\n   */\n  _mediaElementAudioSourceNode = null;\n\n  /**\n   * Represents the timer that is used to reset the variables once the sprite sound is played.\n   * @type {number|null}\n   * @private\n   */\n  _endTimer = null;\n\n  /**\n   * True for sprite.\n   * @type {boolean}\n   * @private\n   */\n  _isSprite = false;\n\n  /**\n   * Last played time.\n   * @type {Date}\n   * @private\n   */\n  _lastPlayed = new Date();\n\n  /**\n   * True to not auto-destroy.\n   * @type {boolean}\n   * @private\n   */\n  _persist = false;\n\n  /**\n   * True if the audio source (buffer or html5 audio) exists.\n   * @type {boolean}\n   * @private\n   */\n  _sourceExists = false;\n\n  /**\n   * True if the HTML5 audio node is pre-loaded.\n   * @type {boolean}\n   * @private\n   */\n  _loaded = false;\n\n  /**\n   * Initializes the internal properties of the sound.\n   * @param {object} args The input parameters of the sound.\n   * @param {number} args.id The unique id of the sound.\n   * @param {boolean} [args.stream = false] True to use HTML5 audio node for playing sound.\n   * @param {Audio} [args.audio] The pre-loaded HTML5 audio object.\n   * @param {AudioBuffer} [args.buffer] Audio source buffer.\n   * @param {number} [args.volume = 1.0] The initial volume of the sound. Should be from 0.0 to 1.0.\n   * @param {number} [args.rate = 1] The initial playback rate of the sound. Should be from 0.5 to 5.0.\n   * @param {boolean} [args.loop = false] True to play the sound repeatedly.\n   * @param {boolean} [args.muted = false] True to be muted initially.\n   * @param {number} [args.startPos] The playback start position.\n   * @param {number} [args.endPos] The playback end position.\n   * @param {function} [args.loadCallback] The callback that will be called when the underlying HTML5 audio node is loaded.\n   * @param {function} [args.playEndCallback] The callback that will be invoked after the play ends.\n   * @param {function} [args.destroyCallback] The callback that will be invoked after destroyed.\n   * @param {function} [args.fadeEndCallback] The callback that will be invoked the fade is completed.\n   * @param {function} [args.audioErrorCallback] The callback that will be invoked when there is error in HTML5 audio node.\n   * @constructor\n   */\n  constructor(args) {\n    this._onBufferEnded = this._onBufferEnded.bind(this);\n    this._onHtml5Ended = this._onHtml5Ended.bind(this);\n    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n    this._onAudioError = this._onAudioError.bind(this);\n\n    const {\n      id,\n      stream,\n      buffer,\n      audio,\n      volume,\n      rate,\n      loop,\n      muted,\n      startPos,\n      endPos,\n      loadCallback,\n      playEndCallback,\n      destroyCallback,\n      fadeEndCallback,\n      audioErrorCallback\n    } = args;\n\n    // Set the passed id or the random one.\n    this._id = typeof id === 'number' ? id : utility.id();\n\n    // Set the passed audio buffer or HTML5 audio node.\n    this._buffer = buffer;\n    this._audio = audio;\n    this._sourceExists = Boolean(this._buffer) || Boolean(this._audio);\n\n    // Set other properties.\n    this._stream = stream;\n    this._sourceExists && (this._endPos = this._stream ? this._audio.duration : this._buffer.duration);\n    volume && (this._volume = volume);\n    rate && (this._rate = rate);\n    muted && (this._muted = muted);\n    loop && (this._loop = loop);\n    startPos && (this._startPos = startPos);\n    endPos && (this._endPos = endPos);\n    this._loadCallback = loadCallback;\n    this._playEndCallback = playEndCallback;\n    this._destroyCallback = destroyCallback;\n    this._fadeEndCallback = fadeEndCallback;\n    this._audioErrorCallback = audioErrorCallback;\n\n    this._duration = this._endPos - this._startPos;\n    this._isSprite = typeof endPos !== 'undefined';\n\n    // If stream is `true` then set the playback rate, looping and listen to `error` event.\n    if (this._stream && this._audio) {\n      this._audio.playbackRate = this._rate;\n      this._setLoop(this._loop);\n      this._audio.addEventListener('error', this._onAudioError);\n    }\n\n    // If web audio is available, create gain node and set the volume..\n    if (engine.isAudioAvailable()) {\n      this._context = engine.context();\n      this._gainNode = this._context.createGain();\n      this._gainNode.gain.setValueAtTime(this._muted ? 0 : this._volume, this._context.currentTime);\n\n      // Create media element audio source node.\n      if (this._stream && this._audio) {\n        this._mediaElementAudioSourceNode = this._context.createMediaElementSource(this._audio);\n        this._mediaElementAudioSourceNode.connect(this._gainNode);\n      }\n    }\n  }\n\n  /**\n   * Sets the audio source for the sound.\n   * @param {AudioBuffer | Audio} source The audio source.\n   */\n  source(source) {\n    if (this._sourceExists) {\n      return;\n    }\n\n    if (this._stream) {\n      this._audio = source;\n      !this._isSprite && (this._endPos = this._audio.duration);\n      this._audio.playbackRate = this._rate;\n\n      this._setLoop(this._loop);\n      this._audio.addEventListener('error', this._onAudioError);\n\n      this._mediaElementAudioSourceNode = this._context.createMediaElementSource(this._audio);\n      this._mediaElementAudioSourceNode.connect(this._gainNode);\n    } else {\n      this._buffer = source;\n      !this._isSprite && (this._endPos = this._buffer.duration);\n    }\n\n    this._sourceExists = true;\n    this._duration = this._endPos - this._startPos;\n    this._loaded = true;\n  }\n\n  /**\n   * Pre-loads the underlying HTML audio node (only in case of stream).\n   */\n  load() {\n    if (!this._stream ||\n      !this._sourceExists ||\n      this.isPlaying() ||\n      this.state() === SoundState.Destroyed) {\n      return;\n    }\n\n    this._audio.addEventListener('canplaythrough', this._onCanPlayThrough);\n    this._audio.currentTime = 0;\n    this.canPlay() && this._onCanPlayThrough();\n  }\n\n  /**\n   * Plays the sound or the sound defined in the sprite.\n   * @return {Sound}\n   */\n  play() {\n    // If the source not exists or sound is already playing then return.\n    if (!this._sourceExists || this.isPlaying()) {\n      return this;\n    }\n\n    this._stream ? this._playHtml5() : this._playBuffer();\n\n    // Record the starting time and set the state.\n    this._startTime = this._context.currentTime;\n    this._state = SoundState.Playing;\n\n    return this;\n  }\n\n  /**\n   * Pauses the playing sound.\n   * @return {Sound}\n   */\n  pause() {\n    // If the source not exists or the sound is already playing return.\n    if (!this._sourceExists || !this.isPlaying()) {\n      return this;\n    }\n\n    // Stop the current running fade.\n    this.fadeStop();\n\n    if (this._stream) {\n      this._audio.removeEventListener('ended', this._onHtml5Ended);\n      this._clearEndTimer();\n      this._audio.pause();\n    } else {\n      this._rateSeek = 0;\n      this._destroyBufferNode();\n    }\n\n    this._currentPos = this.seek();\n    this._state = SoundState.Paused;\n\n    return this;\n  }\n\n  /**\n   * Stops the sound that is playing or in paused state.\n   * @return {Sound}\n   */\n  stop() {\n    // If the source not exists or the sound is not playing or paused return.\n    if (!this._sourceExists || (!this.isPlaying() && !this.isPaused())) {\n      return this;\n    }\n\n    // Stop the current running fade.\n    this.fadeStop();\n\n    if (this._stream) {\n      this._audio.removeEventListener('ended', this._onHtml5Ended);\n      this._clearEndTimer();\n      this._audio.pause();\n      this._audio.currentTime = this._startPos || 0;\n    } else {\n      this._currentPos = 0;\n      this._rateSeek = 0;\n      this._destroyBufferNode();\n    }\n\n    this._lastPlayed = new Date();\n\n    this._state = SoundState.Ready;\n\n    return this;\n  }\n\n  /**\n   * Mutes the sound.\n   * @return {Sound}\n   */\n  mute() {\n    // Stop the current running fade.\n    this.fadeStop();\n\n    // Set the value of gain node to 0.\n    this._gainNode.gain.setValueAtTime(0, this._context.currentTime);\n\n    // Set the muted property true.\n    this._muted = true;\n\n    return this;\n  }\n\n  /**\n   * Un-mutes the sound.\n   * @return {Sound}\n   */\n  unmute() {\n    // Stop the current running fade.\n    this.fadeStop();\n\n    // Reset the gain node's value back to volume.\n    this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime);\n\n    // Set the muted property to false.\n    this._muted = false;\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the volume.\n   * @param {number} [vol] Should be from 0.0 to 1.0.\n   * @return {Sound|number}\n   */\n  volume(vol) {\n    // If no input parameter is passed then return the volume.\n    if (typeof vol === 'undefined') {\n      return this._volume;\n    }\n\n    // Stop the current running fade.\n    this.fadeStop();\n\n    // Set the gain's value to the passed volume.\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : vol, this._context.currentTime);\n\n    // Set the volume to the property.\n    this._volume = vol;\n\n    return this;\n  }\n\n  /**\n   * Fades the sound volume to the passed value in the passed duration.\n   * @param {number} to The destination volume.\n   * @param {number} duration The period of fade.\n   * @param {string} [type = linear] The fade type (linear or exponential).\n   * @return {Sound}\n   */\n  fade(to, duration, type = 'linear') {\n    // If a fade is already running stop it.\n    if (this._fading) {\n      this.fadeStop();\n    }\n\n    this._fading = true;\n\n    if (type === 'linear') {\n      this._gainNode.gain.linearRampToValueAtTime(to, this._context.currentTime + duration);\n    } else {\n      this._gainNode.gain.exponentialRampToValueAtTime(to, this._context.currentTime + duration);\n    }\n\n    this._fadeTimer = workerTimer.setTimeout(() => {\n      this.volume(to);\n\n      workerTimer.clearTimeout(this._fadeTimer);\n\n      this._fadeTimer = null;\n      this._fading = false;\n\n      this._fadeEndCallback && this._fadeEndCallback(this);\n    }, duration * 1000);\n\n    return this;\n  }\n\n  /**\n   * Stops the current running fade.\n   * @return {Sound}\n   */\n  fadeStop() {\n    if (!this._fading) {\n      return this;\n    }\n\n    this._gainNode.gain.cancelScheduledValues(this._context.currentTime);\n\n    if (this._fadeTimer) {\n      workerTimer.clearTimeout(this._fadeTimer);\n      this._fadeTimer = null;\n    }\n\n    this._fading = false;\n    this.volume(this._gainNode.gain.value);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the playback rate.\n   * @param {number} [rate] The playback rate. Should be from 0.5 to 5.\n   * @return {Sound|number}\n   */\n  rate(rate) {\n    // If no input parameter is passed return the current rate.\n    if (typeof rate === 'undefined') {\n      return this._rate;\n    }\n\n    this._rate = rate;\n    this._rateSeek = this.seek();\n\n    if (this.isPlaying()) {\n      if (this._stream) {\n        this._audio.playbackRate = rate;\n\n        if (this._isSprite) {\n          this._clearEndTimer();\n          let [, duration] = this._getTimeVars();\n          this._endTimer = workerTimer.setTimeout(this._onHtml5Ended, (duration * 1000) / Math.abs(rate));\n        }\n      } else {\n        this._startTime = this._context.currentTime;\n        this._bufferSourceNode && (this._bufferSourceNode.playbackRate.setValueAtTime(rate, this._context.currentTime));\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the seek position.\n   * @param {number} [seek] The seek position.\n   * @return {Sound|number}\n   */\n  seek(seek) {\n    // If no parameter is passed return the current position.\n    if (typeof seek === 'undefined') {\n      if (this._stream) {\n        return this._audio ? this._audio.currentTime : null;\n      }\n\n      const realTime = this.isPlaying() ? this._context.currentTime - this._startTime : 0;\n      const rateElapsed = this._rateSeek ? this._rateSeek - this._currentPos : 0;\n      return this._currentPos + (rateElapsed + realTime * this._rate);\n    }\n\n    // If seeking outside the borders then return.\n    if (seek < this._startPos || seek > this._endPos) {\n      return this;\n    }\n\n    // If the sound is currently playing... pause it, set the seek position and then continue playing.\n    const isPlaying = this.isPlaying();\n\n    if (isPlaying) {\n      this.pause();\n    }\n\n    this._currentPos = seek;\n\n    if (isPlaying) {\n      this.play();\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the loop parameter of the sound.\n   * @param {boolean} [loop] True to loop the sound.\n   * @return {Sound/boolean}\n   */\n  loop(loop) {\n    if (typeof loop !== 'boolean') {\n      return this._loop;\n    }\n\n    this._loop = loop;\n    this._setLoop(loop);\n\n    return this;\n  }\n\n  /**\n   * Destroys the dependencies and release the memory.\n   * @return {Sound}\n   */\n  destroy() {\n    // If the sound is already destroyed return.\n    if (this._state === SoundState.Destroyed) {\n      return this;\n    }\n\n    // Stop the sound.\n    this.stop();\n\n    // Destroy the audio node and media element audio source node.\n    this._destroyAudio();\n    this._destroyMediaSourceNode();\n\n    // Disconnect from the master gain.\n    this._gainNode && this._gainNode.disconnect();\n\n    this._buffer = null;\n    this._context = null;\n    this._gainNode = null;\n\n    // Set the state to \"destroyed\".\n    this._state = SoundState.Destroyed;\n\n    this._destroyCallback && this._destroyCallback(this);\n\n    return this;\n  }\n\n  /**\n   * Returns the unique id of the sound.\n   * @return {number}\n   */\n  id() {\n    return this._id;\n  }\n\n  /**\n   * Returns whether the sound is muted or not.\n   * @return {boolean}\n   */\n  muted() {\n    return this._muted;\n  }\n\n  /**\n   * Returns the state of the sound.\n   * @return {SoundState}\n   */\n  state() {\n    return this._state;\n  }\n\n  /**\n   * Returns the total duration of the playback.\n   * @return {number}\n   */\n  duration() {\n    return this._duration;\n  }\n\n  /**\n   * Returns true if the buzz is playing.\n   * @return {boolean}\n   */\n  isPlaying() {\n    return this._state === SoundState.Playing;\n  }\n\n  /**\n   * Returns true if buzz is paused.\n   * @return {boolean}\n   */\n  isPaused() {\n    return this._state === SoundState.Paused;\n  }\n\n  /**\n   * Returns last played time.\n   * @return {number}\n   */\n  lastPlayed() {\n    return this._lastPlayed;\n  }\n\n  /**\n   * Disables auto-destroy.\n   */\n  persist() {\n    if (this._state === SoundState.Destroyed) {\n      return;\n    }\n\n    this._persist = true;\n  }\n\n  /**\n   * Enables auto-destroy.\n   */\n  abandon() {\n    if (this._state === SoundState.Destroyed) {\n      return;\n    }\n\n    this._persist = false;\n  }\n\n  /**\n   * Returns true if auto-destroy enabled.\n   * @return {boolean}\n   */\n  isPersistent() {\n    return this._persist;\n  }\n\n  /**\n   * Returns true if the audio can play without delay.\n   * @return {boolean}\n   */\n  canPlay() {\n    return this._audio ? this._audio.readyState >= 3 : false;\n  }\n\n  /**\n   * HTML5 Audio error handler.\n   * @param {object} err Error object.\n   * @private\n   */\n  _onAudioError(err) {\n    this._audioErrorCallback && this._audioErrorCallback(this, err);\n  }\n\n  /**\n   * Returns the seek, duration and timeout for the playback.\n   * @return {[number, number, number]}\n   * @private\n   */\n  _getTimeVars() {\n    let seek = Math.max(0, this._currentPos > 0 ? this._currentPos : this._startPos),\n      duration = this._endPos - this._startPos,\n      timeout = (duration * 1000) / this._rate;\n\n    return [seek, duration, timeout];\n  }\n\n  /**\n   * Plays the audio using audio buffer.\n   * @private\n   */\n  _playBuffer() {\n    let [seek, duration] = this._getTimeVars();\n\n    // Create a new buffersourcenode to play the sound.\n    this._bufferSourceNode = this._context.createBufferSource();\n\n    // Set the buffer, playback rate and loop parameters\n    this._bufferSourceNode.buffer = this._buffer;\n    this._bufferSourceNode.playbackRate.setValueAtTime(this._rate, this._context.currentTime);\n    this._setLoop(this._loop);\n\n    // Connect the node to the audio graph.\n    this._bufferSourceNode.connect(this._gainNode);\n\n    // Listen to the \"ended\" event to reset/clean things.\n    this._bufferSourceNode.addEventListener('ended', this._onBufferEnded);\n\n    const startTime = this._context.currentTime;\n\n    // Call the supported method to play the sound.\n    if (typeof this._bufferSourceNode.start !== 'undefined') {\n      this._bufferSourceNode.start(startTime, seek, this._loop ? undefined : duration);\n    } else {\n      this._bufferSourceNode.noteGrainOn(startTime, seek, this._loop ? undefined : duration);\n    }\n  }\n\n  /**\n   * Plays the audio using HTML5 audio object.\n   * @private\n   */\n  _playHtml5() {\n    let [seek, , timeout] = this._getTimeVars();\n\n    this._audio.currentTime = seek;\n\n    if (this._isSprite) {\n      this._endTimer = workerTimer.setTimeout(this._onHtml5Ended, timeout);\n    } else {\n      this._audio.addEventListener('ended', this._onHtml5Ended);\n    }\n\n    this._audio.play();\n  }\n\n  /**\n   * Callback that is invoked after the buffer playback is ended.\n   * @private\n   */\n  _onBufferEnded() {\n    this._lastPlayed = new Date();\n\n    // Reset the seek positions\n    this._currentPos = 0;\n    this._rateSeek = 0;\n\n    // Destroy the node (AudioBufferSourceNodes are one-time use and throw objects).\n    this._destroyBufferNode();\n\n    // Reset the state to allow future actions.\n    this._state = SoundState.Ready;\n\n    // Invoke the callback if there is one.\n    this._playEndCallback && this._playEndCallback(this);\n  }\n\n  /**\n   * Callback that is invoked after the html audio playback is ended.\n   * @private\n   */\n  _onHtml5Ended() {\n    if (this._loop) {\n      this.stop().play();\n    } else {\n      this.stop();\n      this._state = SoundState.Ready;\n      this._playEndCallback && this._playEndCallback(this);\n    }\n  }\n\n  /**\n   * Clears the end-timer.\n   * @private\n   */\n  _clearEndTimer() {\n    if (!this._endTimer) {\n      return;\n    }\n\n    workerTimer.clearTimeout(this._endTimer);\n    this._endTimer = null;\n  }\n\n  /**\n   * Event handler for audio's \"canplaythrough\" event.\n   * @private\n   */\n  _onCanPlayThrough() {\n    this._loadCallback();\n    this._audio.removeEventListener('canplaythrough', this._onCanPlayThrough);\n  };\n\n  /**\n   * Returns the gain node.\n   * @return {GainNode}\n   */\n  _gain() {\n    return this._gainNode;\n  }\n\n  /**\n   * Stops the playing buffer source node and destroys it.\n   * @private\n   */\n  _destroyBufferNode() {\n    if (!this._bufferSourceNode) {\n      return;\n    }\n\n    if (typeof this._bufferSourceNode.stop !== 'undefined') {\n      this._bufferSourceNode.stop();\n    } else {\n      this._bufferSourceNode.noteGrainOff();\n    }\n\n    this._bufferSourceNode.disconnect();\n    this._bufferSourceNode.removeEventListener('ended', this._onBufferEnded);\n    this._bufferSourceNode = null;\n  }\n\n  /**\n   * Destroys the media audio source node.\n   * @private\n   */\n  _destroyMediaSourceNode() {\n    if (!this._mediaElementAudioSourceNode) {\n      return;\n    }\n\n    this._mediaElementAudioSourceNode.disconnect();\n    this._mediaElementAudioSourceNode = null;\n  }\n\n  /**\n   * Destroys the passed audio node.\n   * @private\n   */\n  _destroyAudio() {\n    if (!this._audio) {\n      return;\n    }\n\n    this._audio.removeEventListener('canplaythrough', this._onCanPlayThrough);\n    this._audio.removeEventListener('error', this._onAudioError);\n    this._audio.pause();\n    utility.isIE() && (this._audio.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');\n    this._audio.onerror = null;\n    this._audio.onend = null;\n    this._audio.canplaythrough = null;\n    this._audio = null;\n  }\n\n  /**\n   * Sets the sound to play repeatedly or not.\n   * @param {boolean} loop True to play the sound repeatedly.\n   * @private\n   */\n  _setLoop(loop) {\n    if (!this._sourceExists) {\n      return;\n    }\n\n    if (this._stream) {\n      this._audio.loop = loop;\n    } else {\n      this._bufferSourceNode.loop = loop;\n\n      if (loop) {\n        this._bufferSourceNode.loopStart = this._startPos;\n        this._bufferSourceNode.loopEnd = this._endPos;\n      }\n    }\n  }\n}\n\nexport { Sound as default, SoundState };\n","import engine, { EngineEvents, EngineState, ErrorType } from './Engine';\nimport Queue                                            from './Queue';\nimport utility                                          from './Utility';\nimport emitter                                          from './Emitter';\nimport Sound                                            from './Sound';\nimport DownloadStatus                                   from './DownloadStatus';\nimport LoadState                                        from './LoadState';\n\n/**\n * Enum that represents the different states of a buzz (sound group).\n * @enum {string}\n */\nconst BuzzState = {\n  Ready: 'ready',\n  Destroyed: 'destroyed'\n};\n\n/**\n * Enum that represents the different events fired by a buzz.\n * @enum {string}\n */\nconst BuzzEvents = {\n  Load: 'load',\n  LoadProgress: 'loadprogress',\n  UnLoad: 'unload',\n  PlayStart: 'playstart',\n  PlayEnd: 'playend',\n  Pause: 'pause',\n  Stop: 'stop',\n  Volume: 'volume',\n  Mute: 'mute',\n  Seek: 'seek',\n  Rate: 'rate',\n  FadeStart: 'fadestart',\n  FadeEnd: 'fadeend',\n  FadeStop: 'fadestop',\n  Error: 'error',\n  Destroy: 'destroy'\n};\n\n/**\n * A wrapper class that simplifies managing multiple sounds created for a single source.\n */\nclass Buzz {\n\n  /**\n   * Unique id.\n   * @type {number}\n   * @private\n   */\n  _id = -1;\n\n  /**\n   * Represents the source of the sound. The source can be an url or base64 string.\n   * @type {*}\n   * @private\n   */\n  _src = null;\n\n  /**\n   * The formats of the passed audio sources.\n   * @type {Array<string>}\n   * @private\n   */\n  _format = [];\n\n  /**\n   * The sprite definition.\n   * @type {object}\n   * @private\n   */\n  _sprite = null;\n\n  /**\n   * True to use HTML5 audio node.\n   * @type {boolean}\n   * @private\n   */\n  _stream = false;\n\n  /**\n   * The current volume of the sound. Should be from 0.0 to 1.0.\n   * @type {number}\n   * @private\n   */\n  _volume = 1.0;\n\n  /**\n   * The current rate of the playback. Should be from 0.5 to 5.\n   * @type {number}\n   * @private\n   */\n  _rate = 1;\n\n  /**\n   * True if the sound is currently muted.\n   * @type {boolean}\n   * @private\n   */\n  _muted = false;\n\n  /**\n   * True if the sound should play repeatedly.\n   * @type {boolean}\n   * @private\n   */\n  _loop = false;\n\n  /**\n   * True to pre-loaded the sound on construction.\n   * @type {boolean}\n   * @private\n   */\n  _preload = false;\n\n  /**\n   * True to auto-play the sound on construction.\n   * @type {boolean}\n   * @private\n   */\n  _autoplay = false;\n\n  /**\n   * Duration of the playback in seconds.\n   * @type {number}\n   * @private\n   */\n  _duration = 0;\n\n  /**\n   * The best compatible source in the audio sources passed.\n   * @type {string|null}\n   * @private\n   */\n  _compatibleSrc = null;\n\n  /**\n   * Represents the different states that occurs while loading the sound.\n   * @type {LoadState}\n   * @private\n   */\n  _loadState = LoadState.NotLoaded;\n\n  /**\n   * Represents the state of this group.\n   * @type {BuzzState}\n   * @private\n   */\n  _state = BuzzState.Ready;\n\n  /**\n   * True if the group is currently fading.\n   * @type {boolean}\n   * @private\n   */\n  _fading = false;\n\n  /**\n   * The timer that runs function after the fading is complete.\n   * @type {number|null}\n   * @private\n   */\n  _fadeTimer = null;\n\n  /**\n   * Number of audio resource loading calls in progress.\n   * @type {number}\n   * @private\n   */\n  _noOfLoadCalls = 0;\n\n  /**\n   * Array of sounds belongs to this group.\n   * @type {Array<Sound>}\n   * @private\n   */\n  _soundsArray = [];\n\n  /**\n   * Array of pre-loaded HTML5 audio elements.\n   * @type {Array<Audio>}\n   * @private\n   */\n  _audioNodes = [];\n\n  /**\n   * The action queue.\n   * @type {Queue}\n   * @private\n   */\n  _queue = null;\n\n  /**\n   * The audio engine.\n   * @type {Engine}\n   * @private\n   */\n  _engine = null;\n\n  /**\n   * Web API's audio context.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * The group's gain node.\n   * @type {GainNode}\n   * @private\n   */\n  _gainNode = null;\n\n  /**\n   * Initializes the internal properties.\n   * @param {string|Array<string>|object} args The input parameters of this sound group.\n   * @param {string} [args.id] The unique id of the sound.\n   * @param {string|string[]} args.src Single or array of audio urls/base64 strings.\n   * @param {string|string[]} [args.format] The file format(s) of the passed audio source(s).\n   * @param {object} [args.sprite] The audio sprite definition.\n   * @param {boolean} [args.stream = false] True to use HTML5 audio node.\n   * @param {number} [args.volume = 1.0] The initial volume of the sound. Should be from 0.0 to 1.0.\n   * @param {number} [args.rate = 1] The initial playback rate of the sound. Should be from 0.5 to 5.0.\n   * @param {boolean} [args.muted = false] True to be muted initially.\n   * @param {boolean} [args.loop = false] True to play the sound repeatedly.\n   * @param {boolean} [args.preload = false] True to pre-load the sound after construction.\n   * @param {boolean} [args.autoplay = false] True to play automatically after construction.\n   * @param {function} [args.onload] Event-handler for the \"load\" event.\n   * @param {function} [args.onloadprogress] Event-handler for the \"loadprogress\" event (only for non-stream types).\n   * @param {function} [args.onunload] Event-handler for the \"unload\" event.\n   * @param {function} [args.onplaystart] Event-handler for the \"playstart\" event.\n   * @param {function} [args.onplayend] Event-handler for the \"playend\" event.\n   * @param {function} [args.onpause] Event-handler for the \"pause\" event.\n   * @param {function} [args.onstop] Event-handler for the \"stop\" event.\n   * @param {function} [args.onmute] Event-handler for the \"mute\" event.\n   * @param {function} [args.onvolume] Event-handler for the \"volume\" event.\n   * @param {function} [args.onrate] Event-handler for the \"rate\" event.\n   * @param {function} [args.onseek] Event-handler for the \"seek\" event.\n   * @param {function} [args.onerror] Event-handler for the \"error\" event.\n   * @param {function} [args.ondestroy] Event-handler for the \"destroy\" event.\n   * @constructor\n   */\n  constructor(args) {\n    this._engine = engine;\n    this._onLoadProgress = this._onLoadProgress.bind(this);\n\n    if (typeof args === 'string') {\n      if (args.startsWith('#')) {\n        this._setSource(args);\n      } else {\n        this._src = [args];\n      }\n    } else if (Array.isArray(args) && args.length) {\n      this._src = args;\n    } else if (typeof args === 'object') {\n      const {\n        id,\n        src,\n        format,\n        sprite,\n        stream,\n        volume,\n        rate,\n        muted,\n        loop,\n        preload,\n        autoplay,\n        onload,\n        onloadprogress,\n        onunload,\n        onplaystart,\n        onplayend,\n        onpause,\n        onstop,\n        onmute,\n        onvolume,\n        onrate,\n        onseek,\n        onerror,\n        ondestroy\n      } = args;\n\n      // Set the passed id or the auto-generated one.\n      this._id = typeof id === 'number' ? id : utility.id();\n\n      // Set the source.\n      if (typeof src === 'string') {\n        if (src.startsWith('#')) {\n          this._setSource(src);\n        } else {\n          this._src = [src];\n        }\n      } else if (Array.isArray(src)) {\n        this._src = src;\n      }\n\n      // Set the format.\n      if (Array.isArray(format)) {\n        this._format = format;\n      } else if (typeof format === 'string' && format) {\n        this._format = [format];\n      }\n\n      // Set other properties.\n      typeof sprite === 'object' && (this._sprite = sprite);\n      typeof stream === 'boolean' && (this._stream = stream);\n      typeof volume === 'number' && volume >= 0 && volume <= 1.0 && (this._volume = volume);\n      typeof rate === 'number' && rate >= 0.5 && rate <= 5 && (this._rate = rate);\n      typeof muted === 'boolean' && (this._muted = muted);\n      typeof loop === 'boolean' && (this._loop = loop);\n      typeof preload === 'boolean' && (this._preload = preload);\n      typeof autoplay === 'boolean' && (this._autoplay = autoplay);\n\n      // Bind the passed event handlers to events.\n      typeof onload === 'function' && this.on(BuzzEvents.Load, onload);\n      typeof onloadprogress === 'function' && this.on(BuzzEvents.LoadProgress, onloadprogress);\n      typeof onunload === 'function' && this.on(BuzzEvents.UnLoad, onunload);\n      typeof onplaystart === 'function' && this.on(BuzzEvents.PlayStart, onplaystart);\n      typeof onplayend === 'function' && this.on(BuzzEvents.PlayEnd, onplayend);\n      typeof onpause === 'function' && this.on(BuzzEvents.Pause, onpause);\n      typeof onstop === 'function' && this.on(BuzzEvents.Stop, onstop);\n      typeof onmute === 'function' && this.on(BuzzEvents.Mute, onmute);\n      typeof onvolume === 'function' && this.on(BuzzEvents.Volume, onvolume);\n      typeof onrate === 'function' && this.on(BuzzEvents.Rate, onrate);\n      typeof onseek === 'function' && this.on(BuzzEvents.Seek, onseek);\n      typeof onerror === 'function' && this.on(BuzzEvents.Error, onerror);\n      typeof ondestroy === 'function' && this.on(BuzzEvents.Destroy, ondestroy);\n    }\n\n    // Throw error if source is not passed.\n    if (!this._src.length) {\n      throw new Error('You should pass the source for the audio.');\n    }\n\n    // Instantiate the queue.\n    this._queue = new Queue();\n\n    // Setup the audio engine.\n    this._engine.setup();\n\n    // If audio is not supported throw error.\n    if (!this._engine.isAudioAvailable()) {\n      this._fire(BuzzEvents.Error, null, { type: ErrorType.NoAudio, error: 'Web Audio is un-available' });\n      return this;\n    }\n\n    // Store the audio context.\n    this._context = this._engine.context();\n\n    // Add the created buzz to the engine and connect the gain nodes.\n    this._engine.add(this);\n    this._gainNode = this._engine.context().createGain();\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : this._volume, this._context.currentTime);\n    this._gainNode.connect(this._engine.masterGain());\n\n    // Subscribe to engine's resume event.\n    this._engine.on(EngineEvents.Resume, this._onEngineResume = this._onEngineResume.bind(this));\n\n    if (this._autoplay) {\n      this.play();\n    } else if (this._preload) {\n      this.load();\n    }\n  }\n\n  /**\n   * Loads the sound to the underlying audio object.\n   * @param {number} [soundId] The id of the sound to be loaded (for stream types).\n   * @return {Buzz}\n   */\n  load(soundId) {\n    if (soundId) {\n      const sound = this.sound(soundId);\n      sound && sound.load();\n      return this;\n    }\n\n    // If the sound is not of stream and the source is loaded or currently loading then return.\n    if (!this._stream && this._loadState !== LoadState.NotLoaded) {\n      return this;\n    }\n\n    // Set the state to loading.\n    this._loadState = LoadState.Loading;\n\n    // Increment the calls which is needed for stream types.\n    this._noOfLoadCalls = this._noOfLoadCalls + 1;\n\n    // Get the first compatible source.\n    const src = this._compatibleSrc || (this._compatibleSrc = this.getCompatibleSource());\n\n    // Load the audio source.\n    const load$ = this._stream ? this._engine.allocateForGroup(src, this._id) : this._engine.load(src, this._onLoadProgress);\n    load$.then(downloadResult => {\n      this._noOfLoadCalls > 0 && (this._noOfLoadCalls = this._noOfLoadCalls - 1);\n\n      // During the loading, if buzz is destroyed or un-loaded then return.\n      if (this._state === BuzzState.Destroyed || this._loadState === LoadState.NotLoaded) {\n        this._stream && this._engine.releaseForGroup(this._compatibleSrc, this._id);\n        return;\n      }\n\n      // If loading succeeded,\n      // i. Save the result.\n      // ii. Set the load state as loaded.\n      // iii. Fire the load event.\n      // iv. Run the methods that are queued to run after successful load.\n      if (downloadResult.status === DownloadStatus.Success) {\n        if (this._stream) {\n          this._duration = downloadResult.value.duration;\n        } else {\n          this._buffer = downloadResult.value;\n          this._duration = this._buffer.duration;\n        }\n\n        this._loadState = LoadState.Loaded;\n        this._fire(BuzzEvents.Load, null, downloadResult);\n\n        if (this._engine.state() !== EngineState.Ready) {\n          this._queue.remove('after-load');\n          return;\n        }\n\n        this._queue.run('after-load');\n\n        return;\n      }\n\n      this._onLoadFailure(downloadResult.error);\n    });\n\n    return this;\n  }\n\n  /**\n   * Returns the first compatible source based on the passed sources and the format.\n   * @return {string}\n   */\n  getCompatibleSource() {\n    // If the user has passed \"format\", check if it is supported or else retrieve the first supported source from the array.\n    return this._format.length ?\n      this._src[this._format.indexOf(utility.getSupportedFormat(this._format))] :\n      utility.getSupportedSource(this._src);\n  }\n\n  /**\n   * Plays the passed sound defined in the sprite or the sound that belongs to the passed id.\n   * @param {string|number} [soundOrId] The sound name defined in sprite or the sound id.\n   * @return {Buzz|number}\n   */\n  play(soundOrId) {\n    const isIdPassed = typeof soundOrId === 'number';\n\n    // If id is passed then get the sound from the engine and play it.\n    if (isIdPassed) {\n      const sound = this.sound(soundOrId);\n      sound && this._play(sound);\n      return this;\n    }\n\n    // Create a unique id for sound.\n    const newSoundId = utility.id();\n\n    // Create the arguments of the sound.\n    const soundArgs = {\n      id: newSoundId,\n      stream: this._stream,\n      volume: this._volume,\n      rate: this._rate,\n      muted: this._muted,\n      loop: this._loop,\n      playEndCallback: () => this._fire(BuzzEvents.PlayEnd, newSoundId),\n      fadeEndCallback: () => this._fire(BuzzEvents.FadeEnd, newSoundId),\n      audioErrorCallback: (sound, err) => this._fire(BuzzEvents.Error, newSoundId, { type: ErrorType.LoadError, error: err }),\n      loadCallback: () => this._fire(BuzzEvents.Load, newSoundId),\n      destroyCallback: () => {\n        this._removeSound(newSoundId);\n        this._engine.releaseForSound(this._compatibleSrc, this._id, newSoundId);\n        this._fire(BuzzEvents.Destroy, newSoundId);\n        emitter.clear(newSoundId);\n      }\n    };\n\n    // In case of sprite, set the positions.\n    if (typeof soundOrId === 'string' && this._sprite && this._sprite.hasOwnProperty(soundOrId)) {\n      const positions = this._sprite[soundOrId];\n      soundArgs.startPos = positions[0];\n      soundArgs.endPos = positions[1];\n    }\n\n    // Create the sound and connect the gains.\n    const newSound = new Sound(soundArgs);\n    newSound._gain().connect(this._gainNode);\n    this._soundsArray.push(newSound);\n\n    const playSound = () => {\n      newSound.source(this._stream ? this._engine.allocateForSound(this._compatibleSrc, this._id, newSoundId) : this._buffer);\n      this._play(newSound);\n    };\n\n    // If the sound is not yet loaded push an action to the queue to play the sound once it's loaded.\n    if (!this.isLoaded()) {\n      this._queue.add('after-load', `play-${newSoundId}`, () => playSound());\n      this.load();\n    } else {\n      playSound();\n    }\n\n    return newSoundId;\n  }\n\n  /**\n   * Pauses the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  pause(id) {\n    const isGroup = typeof id === 'undefined';\n    this._removePlayActions(id);\n    isGroup && this.fadeStop();\n    this._sounds(id).forEach(sound => sound.pause());\n    this._fire(BuzzEvents.Pause, id);\n\n    return this;\n  }\n\n  /**\n   * Stops the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  stop(id) {\n    const isGroup = typeof id === 'undefined';\n    this._removePlayActions(id);\n    isGroup && this.fadeStop();\n    this._sounds(id).forEach(sound => sound.stop());\n    this._fire(BuzzEvents.Stop, id);\n\n    return this;\n  }\n\n  /**\n   * Mutes the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  mute(id) {\n    const isGroup = typeof id === 'undefined';\n\n    if (isGroup) {\n      this.fadeStop();\n      this._gainNode.gain.setValueAtTime(0, this._context.currentTime);\n      this._muted = true;\n    } else {\n      const sound = this.sound(id);\n      sound && sound.mute();\n    }\n\n    this._fire(BuzzEvents.Mute, id, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Un-mutes the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  unmute(id) {\n    const isGroup = typeof id === 'undefined';\n\n    if (isGroup) {\n      this.fadeStop();\n      this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime);\n      this._muted = false;\n    } else {\n      const sound = this.sound(id);\n      sound && sound.unmute();\n    }\n\n    this._fire(BuzzEvents.Mute, id, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the volume of the passed sound or the group.\n   * @param {number} [volume] Should be from 0.0 to 1.0.\n   * @param {number} [id] The sound id.\n   * @return {Buzz|number}\n   */\n  volume(volume, id) {\n    const isGroup = typeof id === 'undefined';\n\n    if (typeof volume === 'number' && volume >= 0 && volume <= 1.0) {\n      if (isGroup) {\n        this.fadeStop();\n        this._gainNode.gain.setValueAtTime(this._muted ? 0 : volume, this._context.currentTime);\n        this._volume = volume;\n      } else {\n        const sound = this.sound(id);\n        sound && sound.volume(volume);\n      }\n\n      this._fire(BuzzEvents.Volume, id, this._volume);\n      return this;\n    }\n\n    if (!isGroup) {\n      const sound = this.sound(id);\n      return sound ? sound.volume() : null;\n    }\n\n    return this._volume;\n  }\n\n  /**\n   * Fades the group's or passed sound's volume to the passed value in the passed duration.\n   * @param {number} to The destination volume.\n   * @param {number} duration The period of fade in seconds.\n   * @param {string} [type = linear] The fade type (linear or exponential).\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  fade(to, duration, type = 'linear', id) {\n    const isGroup = typeof id === 'undefined';\n\n    if (isGroup && this._fading) {\n      return this;\n    }\n\n    this._fire(BuzzEvents.FadeStart, id);\n\n    if (isGroup) {\n      this._fading = true;\n\n      if (type === 'linear') {\n        this._gainNode.gain.linearRampToValueAtTime(to, this._context.currentTime + duration);\n      } else {\n        this._gainNode.gain.exponentialRampToValueAtTime(to, this._context.currentTime + duration);\n      }\n\n      this._fadeTimer = setTimeout(() => {\n        this.volume(to);\n\n        clearTimeout(this._fadeTimer);\n\n        this._fadeTimer = null;\n        this._fading = false;\n        this._fire(BuzzEvents.FadeEnd);\n      }, duration * 1000);\n    } else {\n      const sound = this.sound(id);\n      sound && sound.fade(to, duration, type);\n    }\n\n    return this;\n  }\n\n  /**\n   * Stops the group's or passed sound's current running fade.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  fadeStop(id) {\n    const isGroup = typeof id === 'undefined';\n\n    if (isGroup) {\n      if (!this._fading) {\n        return this;\n      }\n\n      this._gainNode.gain.cancelScheduledValues(this._context.currentTime);\n\n      if (this._fadeTimer) {\n        clearTimeout(this._fadeTimer);\n        this._fadeTimer = null;\n      }\n\n      this._fading = false;\n    } else {\n      const sound = this.sound(id);\n      sound && sound.fadeStop();\n    }\n\n    this._fire(BuzzEvents.FadeStop, id);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the rate of the passed sound or the group.\n   * @param {number} [rate] Should be from 0.5 to 5.0.\n   * @param {number} [id] The sound id.\n   * @return {Buzz|number}\n   */\n  rate(rate, id) {\n    const isGroup = typeof id === 'undefined';\n\n    if (typeof rate === 'number' && rate >= 0.5 && rate <= 5) {\n      this._sounds(id).forEach(sound => sound.rate(rate));\n      isGroup && (this._rate = rate);\n      this._fire(BuzzEvents.Rate, id, this._rate);\n      return this;\n    }\n\n    if (!isGroup) {\n      const sound = this.sound(id);\n      return sound ? sound.rate() : null;\n    }\n\n    return this._rate;\n  }\n\n  /**\n   * Gets/sets the current playback position of the sound.\n   * @param {number} id The sound id\n   * @param {number} [seek] The seek position.\n   * @return {Buzz|number}\n   */\n  seek(id, seek) {\n    const sound = this.sound(id);\n\n    if (!sound) {\n      return this;\n    }\n\n    if (typeof seek === 'number') {\n      // If the audio source is not yet loaded push an item to the queue to seek after the sound is loaded\n      // and load the sound.\n      if (!this.isLoaded()) {\n        this._queue.add('after-load', `seek-${id}`, () => this.seek(id, seek));\n        this.load();\n        return this;\n      }\n\n      sound.seek(seek);\n      this._fire(BuzzEvents.Seek, id, seek);\n      return this;\n    }\n\n    return sound.seek();\n  }\n\n  /**\n   * Gets/sets the looping behavior of a sound or the group.\n   * @param {boolean} [loop] True to loop the sound.\n   * @param {number} [id] The sound id.\n   * @return {Buzz|boolean}\n   */\n  loop(loop, id) {\n    const isGroup = typeof id === 'undefined';\n\n    if (typeof loop === 'boolean') {\n      this._sounds(id).forEach(sound => sound.loop(loop));\n      isGroup && (this._loop = loop);\n      return this;\n    }\n\n    if (!isGroup) {\n      const sound = this.sound(id);\n      return sound ? sound.loop() : null;\n    }\n\n    return this._loop;\n  }\n\n  /**\n   * Returns true if the passed sound is playing.\n   * @param {number} id The sound id.\n   * @return {boolean}\n   */\n  playing(id) {\n    const sound = this.sound(id);\n    return sound ? sound.isPlaying() : null;\n  }\n\n  /**\n   * Returns true if the passed sound is muted or the group is muted.\n   * @param {number} [id] The sound id.\n   * @return {boolean}\n   */\n  muted(id) {\n    if (typeof id === 'undefined') {\n      return this._muted;\n    }\n\n    const sound = this.sound(id);\n    return sound ? sound.muted() : null;\n  }\n\n  /**\n   * Returns the state of the passed sound or the group.\n   * @param {number} [id] The sound id.\n   * @return {BuzzState|SoundState}\n   */\n  state(id) {\n    if (typeof id === 'undefined') {\n      return this._state;\n    }\n\n    const sound = this.sound(id);\n    return sound ? sound.state() : null;\n  }\n\n  /**\n   * Returns the duration of the passed sound or the total duration of the sound.\n   * @param {number} [id] The sound id.\n   * @return {number}\n   */\n  duration(id) {\n    if (typeof id === 'undefined') {\n      return this._duration;\n    }\n\n    const sound = this.sound(id);\n    return sound ? sound.duration() : null;\n  }\n\n  /**\n   * Unloads the loaded audio buffer or free audio nodes.\n   * @return {Buzz}\n   */\n  unload() {\n    this._queue.remove('after-load');\n    this._stream && this._engine.releaseForGroup(this._compatibleSrc, this._id);\n    this._buffer = null;\n    this._duration = 0;\n    this._loadState = LoadState.NotLoaded;\n    this._noOfLoadCalls = 0;\n    this._fire(BuzzEvents.UnLoad);\n    return this;\n  }\n\n  /**\n   * Stops and destroys all the sounds belongs to this group and release other dependencies.\n   * @param {number} [soundId] The sound id.\n   */\n  destroy(soundId) {\n    if (soundId) {\n      const sound = this.sound(soundId);\n      sound && sound.destroy();\n      return;\n    }\n\n    if (this._state === BuzzState.Destroyed) {\n      return;\n    }\n\n    this.stop();\n    this._soundsArray.forEach(sound => sound.destroy());\n    this._queue.clear();\n    this._engine.off(EngineEvents.Resume, this._onEngineResume);\n    this._stream && this._engine.releaseForGroup(this._compatibleSrc, this._id);\n    this._gainNode.disconnect();\n    this._engine.remove(this);\n\n    this._soundsArray = [];\n    this._buffer = null;\n    this._queue = null;\n    this._context = null;\n    this._engine = null;\n    this._gainNode = null;\n    this._state = BuzzState.Destroyed;\n\n    this._fire(BuzzEvents.Destroy);\n\n    emitter.clear(this._id);\n  }\n\n  /**\n   * Makes the passed sound persistent that means it can't be auto-destroyed.\n   * @param {number} soundId The sound id.\n   */\n  persist(soundId) {\n    const sound = this.sound(soundId);\n    sound && sound.persist();\n  }\n\n  /**\n   * Makes the passed sound un-persistent that means it can be auto-destroyed.\n   * @param {number} soundId The sound id.\n   */\n  abandon(soundId) {\n    const sound = this.sound(soundId);\n    sound && sound.abandon();\n  }\n\n  /**\n   * Removes the inactive sounds.\n   */\n  free() {\n    const now = new Date();\n\n    this._soundsArray = this._soundsArray.filter(sound => {\n      const inactiveDurationInSeconds = (now - sound.lastPlayed()) / 1000;\n\n      if (sound.isPersistent() ||\n        sound.isPlaying() ||\n        sound.isPaused() ||\n        inactiveDurationInSeconds < this._engine.inactiveTime() * 60) {\n        return true;\n      }\n\n      sound.destroy();\n      return false;\n    });\n  }\n\n  /**\n   * Subscribes to an event for the sound or the group.\n   * @param {string} eventName The event name.\n   * @param {function} handler The event handler.\n   * @param {boolean} [once = false] True for one-time event handling.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  on(eventName, handler, once = false, id) {\n    emitter.on(id || this._id, eventName, handler, once);\n    return this;\n  }\n\n  /**\n   * Un-subscribes from an event for the sound or the group.\n   * @param {string} eventName The event name.\n   * @param {function} handler The event handler.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  off(eventName, handler, id) {\n    emitter.off(id || this._id, eventName, handler);\n    return this;\n  }\n\n  /**\n   * Returns the unique id of the sound.\n   * @return {number}\n   */\n  id() {\n    return this._id;\n  }\n\n  /**\n   * Returns the gain node.\n   * @return {GainNode}\n   */\n  gain() {\n    return this._gainNode;\n  }\n\n  /**\n   * Returns the audio resource loading status.\n   * @return {LoadState}\n   */\n  loadState() {\n    return this._loadState;\n  }\n\n  /**\n   * Returns true if the audio source is loaded.\n   * @return {boolean}\n   */\n  isLoaded() {\n    return this._stream ? this._engine.hasFreeNodes(this._compatibleSrc, this._id) : this._loadState === LoadState.Loaded;\n  }\n\n  /**\n   * Returns the sound for the passed id.\n   * @param {number} id The sound id.\n   * @return {Sound}\n   */\n  sound(id) {\n    return this._soundsArray.find(x => x.id() === id);\n  }\n\n  /**\n   * Returns all the sounds.\n   * @return {Array<Sound>}\n   */\n  sounds() {\n    return this._soundsArray;\n  }\n\n  /**\n   * Returns true if the passed sound exists.\n   * @param {number} id The sound id.\n   * @return {boolean}\n   */\n  alive(id) {\n    return Boolean(this.sound(id));\n  }\n\n  /**\n   * Sets source, format and sprite from the assigned key.\n   * @param {string} key The source key.\n   * @private\n   */\n  _setSource(key) {\n    const src = this._engine.getSource(key.substring(1));\n\n    if (typeof src === 'string') {\n      this._src = [src];\n    } else if (Array.isArray(src)) {\n      this._src = src;\n    } else if (typeof src === 'object') {\n      const {\n        url,\n        format,\n        sprite\n      } = src;\n\n      if (typeof url === 'string') {\n        this._src = [url];\n      } else if (Array.isArray(url)) {\n        this._src = url;\n      }\n\n      if (Array.isArray(format)) {\n        this._format = format;\n      } else if (typeof format === 'string' && format) {\n        this._format = [format];\n      }\n\n      typeof sprite === 'object' && (this._sprite = sprite);\n    }\n  }\n\n  /**\n   * Called on failure of loading audio source.\n   * @param {*} error The audio source load error.\n   * @private\n   */\n  _onLoadFailure(error) {\n    // Remove the queued actions from this class that are supposed to run after load.\n    this._noOfLoadCalls === 0 && this._queue.remove('after-load');\n\n    // Set the load state back to not loaded.\n    this._loadState = LoadState.NotLoaded;\n\n    // Fire the error event.\n    this._fire(BuzzEvents.Error, null, { type: ErrorType.LoadError, error: error });\n  }\n\n  /**\n   * The resource load progress handler.\n   * @param {object} evt The progress data.\n   * @private\n   */\n  _onLoadProgress(evt) {\n    this._fire(BuzzEvents.LoadProgress, null, evt.percentageDownloaded);\n  }\n\n  /**\n   * Whenever the engine resume run the actions queued for it.\n   * @private\n   */\n  _onEngineResume() {\n    this._queue.run('after-engine-resume');\n  }\n\n  /**\n   * Checks the engine state and plays the passed sound.\n   * @param {Sound} sound The sound.\n   * @private\n   */\n  _play(sound) {\n    if (this._engine.state() === EngineState.Destroying || this._engine.state() === EngineState.Done) {\n      this._fire(BuzzEvents.Error, null, { type: ErrorType.PlayError, error: 'The engine is stopping/stopped' });\n      return;\n    }\n\n    if (this._engine.state() === EngineState.NoAudio) {\n      this._fire(BuzzEvents.Error, null, { type: ErrorType.NoAudio, error: 'Web Audio is un-available' });\n      return;\n    }\n\n    const playAndFire = () => {\n      sound.play();\n      this._fire(BuzzEvents.PlayStart, sound.id());\n    };\n\n    if ([EngineState.Suspending, EngineState.Suspended, EngineState.Resuming].indexOf(this._engine.state()) > -1) {\n      this._queue.add('after-engine-resume', `sound-${sound.id()}`, () => playAndFire());\n      this._engine.state() !== EngineState.Resuming && this._engine.resume();\n      return;\n    }\n\n    playAndFire();\n  }\n\n  /**\n   * Remove the play actions queued from the queue.\n   * @param {number} [id] The sound id.\n   * @private\n   */\n  _removePlayActions(id) {\n    this._queue.remove('after-load', id ? `play-${id}` : null);\n    this._queue.remove('after-engine-resume', id ? `sound-${id}` : null);\n  }\n\n  /**\n   * Returns the sound for the passed id or all the sounds belong to this group.\n   * @param {number} [id] The sound id.\n   * @return {Array<Sound>}\n   * @private\n   */\n  _sounds(id) {\n    if (typeof id === 'number') {\n      const sound = this._soundsArray.find(x => x.id() === id);\n      return sound ? [sound] : [];\n    }\n\n    return this._soundsArray;\n  }\n\n  /**\n   * Removes the passed sound from the array.\n   * @param {number|Sound} sound The sound.\n   * @private\n   */\n  _removeSound(sound) {\n    if (typeof sound === 'number') {\n      this._soundsArray = this._soundsArray.filter(x => x.id() !== sound);\n      return;\n    }\n\n    this._soundsArray.splice(this._soundsArray.indexOf(sound), 1);\n  }\n\n  /**\n   * Fires an event of group or sound.\n   * @param {string} eventName The event name.\n   * @param {number} [id] The sound id.\n   * @param {...*} args The arguments that to be passed to handler.\n   * @return {Buzz}\n   * @private\n   */\n  _fire(eventName, id, ...args) {\n    if (id) {\n      emitter.fire(id, eventName, ...args, this.sound(id), this);\n      emitter.fire(this._id, eventName, ...args, this.sound(id), this);\n    } else {\n      emitter.fire(this._id, eventName, ...args, this);\n    }\n\n    return this;\n  }\n}\n\nconst $buzz = args => new Buzz(args);\n[\n  'setup',\n  'play',\n  'pause',\n  'register',\n  'unregister',\n  'getSource',\n  'load',\n  'loadMedia',\n  'unload',\n  'unloadMedia',\n  'mute',\n  'unmute',\n  'volume',\n  'fade',\n  'fadeStop',\n  'rate',\n  'seek',\n  'loop',\n  'destroy',\n  'stop',\n  'suspend',\n  'resume',\n  'terminate',\n  'muted',\n  'state',\n  'context',\n  'masterGain',\n  'isAudioAvailable',\n  'bufferLoader',\n  'mediaLoader',\n  'on',\n  'off',\n  'buzz',\n  'buzzes',\n  'sound',\n  'sounds'\n].forEach(method => {\n  $buzz[method] = function () {\n    const result = engine[method](...arguments);\n    return result === engine ? $buzz : result;\n  };\n});\n\nmodule.exports = $buzz;\n","import utility from './Utility';\nimport DownloadResult from './DownloadResult';\n\n/**\n * Loads the audio sources into audio buffers and returns them.\n * The loaded buffers are cached.\n * @class\n */\nclass BufferLoader {\n\n  /**\n   * AudioContext.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * In-memory audio buffer cache store.\n   * @type {object}\n   * @private\n   */\n  _bufferCache = {};\n\n  /**\n   * Dictionary to store the current progress calls and their callbacks.\n   * @type {object}\n   * @private\n   */\n  _progressCallsAndCallbacks = {};\n\n  /**\n   * True if the loader is disposed.\n   * @type {boolean}\n   * @private\n   */\n  _disposed = false;\n\n  /**\n   * Create the cache.\n   * @param {AudioContext} context The Audio Context\n   */\n  constructor(context) {\n    this._context = context;\n  }\n\n  /**\n   * Loads single or multiple audio resources into audio buffers.\n   * @param {string|string[]} urls Single or array of audio urls.\n   * @param {function} [progressCallback] The callback that is called to intimate the percentage downloaded.\n   * @return {Promise<DownloadResult|Array<DownloadResult>>}\n   */\n  load(urls, progressCallback) {\n    if (typeof urls === 'string') {\n      return this._load(urls, progressCallback);\n    }\n\n    return Promise.all(urls.map(url => this._load(url, progressCallback)));\n  }\n\n  /**\n   * Removes the cached audio buffers.\n   * @param {string|string[]} [urls] Single or array of audio urls\n   */\n  unload(urls) {\n    if (typeof urls === 'string') {\n      this._unload(urls);\n      return;\n    }\n\n    if (Array.isArray(urls)) {\n      urls.forEach(url => this._unload(url), this);\n      return;\n    }\n\n    this._bufferCache = {};\n  }\n\n  /**\n   * Dispose the loader.\n   */\n  dispose() {\n    if (this._disposed) {\n      return;\n    }\n\n    this.unload();\n    this._bufferCache = null;\n    this._progressCallsAndCallbacks = null;\n    this._context = null;\n    this._disposed = true;\n  }\n\n  /**\n   * Loads a single audio resource into audio buffer and cache result if the download is succeeded.\n   * @param {string} url The Audio url.\n   * @param {function} [progressCallback] The callback that is called to intimate the percentage downloaded.\n   * @return {Promise<DownloadResult>}\n   * @private\n   */\n  _load(url, progressCallback) {\n    return new Promise(resolve => {\n      if (this._bufferCache.hasOwnProperty(url)) {\n        resolve(new DownloadResult(url, this._bufferCache[url]));\n        return;\n      }\n\n      if (this._progressCallsAndCallbacks.hasOwnProperty(url)) {\n        this._progressCallsAndCallbacks[url].push(resolve);\n        return;\n      }\n\n      this._progressCallsAndCallbacks[url] = [];\n      this._progressCallsAndCallbacks[url].push(resolve);\n\n      const reject = err => {\n        if (this._disposed) {\n          return;\n        }\n\n        this._progressCallsAndCallbacks[url].forEach(r => r(new DownloadResult(url, null, err)));\n        delete this._progressCallsAndCallbacks[url];\n      };\n\n      const decodeAudioData = arrayBuffer => {\n        if (this._disposed) {\n          return;\n        }\n\n        this._context.decodeAudioData(arrayBuffer, buffer => {\n          this._bufferCache[url] = buffer;\n          this._progressCallsAndCallbacks[url].forEach(r => r(new DownloadResult(url, buffer)));\n          delete this._progressCallsAndCallbacks[url];\n        }, reject);\n      };\n\n      if (utility.isBase64(url)) {\n        const data = atob(url.split(',')[1]);\n        const dataView = new Uint8Array(data.length); // eslint-disable-line no-undef\n\n        for (let i = 0; i < data.length; i++) {\n          dataView[i] = data.charCodeAt(i);\n        }\n\n        decodeAudioData(dataView.buffer);\n        return;\n      }\n\n      const req = new XMLHttpRequest();\n      req.open('GET', url, true);\n      req.responseType = 'arraybuffer';\n\n      req.addEventListener('load', () => decodeAudioData(req.response), false);\n\n      if (progressCallback) {\n        req.addEventListener('progress', (evt) => {\n          if (!evt.lengthComputable) {\n            progressCallback({ url: url, percentageDownloaded: 0 });\n          }\n\n          const percentageDownloaded = Math.round((evt.loaded / evt.total) * 100);\n          progressCallback({ url: url, percentageDownloaded: percentageDownloaded });\n        });\n      }\n\n      req.addEventListener('error', reject, false);\n      req.send();\n    });\n  }\n\n  /**\n   * Removes the single cached audio buffer.\n   * @param {string} url Audio url\n   * @private\n   */\n  _unload(url) {\n    delete this._bufferCache[url];\n  }\n}\n\nexport default BufferLoader;\n","import Html5AudioPool from './Html5AudioPool';\nimport DownloadResult from './DownloadResult';\n\n/**\n * Loads the HTML5 audio nodes and returns them.\n * @class\n */\nclass MediaLoader {\n\n  /**\n   * HTML5 audio pool.\n   * @type {Html5AudioPool}\n   * @private\n   */\n  _audioPool = null;\n\n  /**\n   * Store the array of audio elements that are currently in buffering state.\n   * @type {Array}\n   * @private\n   */\n  _bufferingAudios = [];\n\n  /**\n   * True if the loader is disposed.\n   * @type {boolean}\n   * @private\n   */\n  _disposed = false;\n\n  /**\n   * Creates the audio pool.\n   * @param {number} maxNodesPerSource Maximum number of audio nodes allowed for a url.\n   * @param {number} inactiveTime The period after which HTML5 audio node is marked as inactive.\n   * @param {function} soundCleanUpCallback The inactive sounds cleanup callback.\n   */\n  constructor(maxNodesPerSource, inactiveTime, soundCleanUpCallback) {\n    this._audioPool = new Html5AudioPool(maxNodesPerSource, inactiveTime, soundCleanUpCallback);\n  }\n\n  /**\n   * Preloads the HTML5 audio nodes with audio and return them.\n   * @param {string|string[]} urls Single or array of audio file urls.\n   * @return {Promise<DownloadResult|Array<DownloadResult>>}\n   */\n  load(urls) {\n    if (typeof urls === 'string') {\n      return this._load(urls);\n    }\n\n    return Promise.all(urls.map(url => this._load(url)));\n  }\n\n  /**\n   * Allocates audio node for a group.\n   * @param {string} url The audio file url.\n   * @param {number} groupId The group id.\n   * @return {Promise<DownloadResult>}\n   */\n  allocateForGroup(url, groupId) {\n    return this._load(url, groupId);\n  }\n\n  /**\n   * Allocates an audio node for sound and returns it.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The buzz id.\n   * @param {number} soundId The sound id.\n   * @return {Audio}\n   */\n  allocateForSound(src, groupId, soundId) {\n    return this._audioPool.allocateForSound(src, groupId, soundId);\n  }\n\n  /**\n   * Releases the allocated audio node(s) for the passed urls.\n   * @param {string|string[]} [urls] Single or array of audio file urls.\n   */\n  unload(urls) {\n    const removeAudioObjOfUrl = url => {\n      const audioObj = this._bufferingAudios.find(a => a.url === url);\n      audioObj && this._cleanUp(audioObj);\n    };\n\n    if (!urls) {\n      this._bufferingAudios.forEach(audioObj => this._cleanUp(audioObj));\n      this._audioPool.release();\n    } else if (typeof urls === 'string') {\n      removeAudioObjOfUrl(urls);\n      this._audioPool.releaseForSource(urls);\n    } else if (Array.isArray(urls) && urls.length) {\n      urls.forEach(url => {\n        removeAudioObjOfUrl(url);\n        this._audioPool.releaseForSource(url);\n      });\n    }\n  }\n\n  /**\n   * Releases the allocated audio node for the passed group.\n   * @param {string} url The audio file url.\n   * @param {number} groupId The group id.\n   */\n  releaseForGroup(url, groupId) {\n    this._bufferingAudios\n      .filter(a => a.groupId === groupId)\n      .forEach(a => this._cleanUp(a));\n\n    this._audioPool.releaseForGroup(url, groupId);\n  }\n\n  /**\n   * Destroys the audio node reserved for sound.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The buzz id.\n   * @param {number} soundId The sound id.\n   */\n  releaseForSound(src, groupId, soundId) {\n    this._audioPool.releaseAudio(src, groupId, soundId);\n  }\n\n  /**\n   * Returns if there are free audio nodes available for a group.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The group id.\n   * @return {boolean}\n   */\n  hasFreeNodes(src, groupId) {\n    return this._audioPool.hasFreeNodes(src, groupId);\n  }\n\n  /**\n   * Acquires the unallocated audio nodes and removes the excess ones.\n   */\n  cleanUp() {\n    this._audioPool.cleanUp();\n  }\n\n  /**\n   * Clear the event handlers of buffering audio elements and dispose the pool.\n   */\n  dispose() {\n    if (this._disposed) {\n      return;\n    }\n\n    [...this._bufferingAudios].forEach(audioObj => this._cleanUp(audioObj));\n    this._bufferingAudios = null;\n    this._audioPool.dispose();\n    this._audioPool = null;\n    this._disposed = true;\n  }\n\n  /**\n   * Preload the HTML5 audio element with the passed audio file and allocate it to the passed sound (if any).\n   * @param {string} url The audio file url.\n   * @param {number} [groupId] The buzz id.\n   * @return {Promise}\n   * @private\n   */\n  _load(url, groupId) {\n    return new Promise(resolve => {\n      const audio = groupId ? this._audioPool.allocateForGroup(url, groupId) : this._audioPool.allocateForSource(url);\n\n      const onCanPlayThrough = () => {\n        if (this._disposed) {\n          return;\n        }\n\n        const audioObj = this._bufferingAudios.find(obj => obj.audio === audio);\n        audioObj && this._cleanUp(audioObj);\n        resolve(new DownloadResult(url, audio));\n      };\n\n      const onError = (err) => {\n        if (this._disposed) {\n          return;\n        }\n\n        const audioObj = this._bufferingAudios.find(obj => obj.audio === audio);\n        audioObj && this._cleanUp(audioObj);\n        this._audioPool.releaseAudio(url, groupId, audio);\n        resolve(new DownloadResult(url, null, err));\n      };\n\n      audio.addEventListener('canplaythrough', onCanPlayThrough);\n      audio.addEventListener('error', onError);\n\n      this._bufferingAudios.push({\n        url: url,\n        groupId: groupId,\n        audio: audio,\n        canplaythrough: onCanPlayThrough,\n        error: onError\n      });\n\n      if (!audio.src) { // new audio element?\n        audio.src = url;\n        audio.load();\n        return;\n      }\n\n      audio.currentTime = 0;\n\n      if (audio.readyState >= 3) {\n        onCanPlayThrough();\n      }\n    });\n  }\n\n  /**\n   * Removes the event-handlers from the audio element.\n   * @param {object} audioObj The buffering audio object.\n   * @private\n   */\n  _cleanUp(audioObj) {\n    ['canplaythrough', 'error'].forEach(evt => audioObj.audio.removeEventListener(evt, audioObj[audioObj]));\n    this._bufferingAudios.splice(this._bufferingAudios.indexOf(audioObj), 1);\n  }\n}\n\nexport default MediaLoader;\n","import utility from './Utility';\n\n/**\n * Manages the pool of HTML5 audio nodes.\n * @class\n */\nclass Html5AudioPool {\n\n  /**\n   * Maximum number of HTML5 audio nodes that can be allocated for a resource.\n   * @type {number}\n   * @private\n   */\n  _maxNodesPerSource = 100;\n\n  /**\n   * Inactive time of sound/HTML5 audio.\n   * @type {number}\n   * @private\n   */\n  _inactiveTime = 2;\n\n  /**\n   * The sounds store.\n   * @type {function}\n   * @private\n   */\n  _soundCleanUpCallback = null;\n\n  /**\n   * Created audio nodes for each resource.\n   * @type {object}\n   * @private\n   */\n  _resourceNodesMap = {};\n\n  /**\n   * True if the `soundCleanUpCallback` called.\n   * @type {boolean}\n   * @private\n   */\n  _cleanUpCalled = false;\n\n  /**\n   * Constructor\n   * @param {number} maxNodesPerSource Maximum number of audio nodes allowed for a resource.\n   * @param {number} inactiveTime The period after which HTML5 audio node is marked as inactive.\n   * @param {function} soundCleanUpCallback The inactive sounds cleanup callback.\n   */\n  constructor(maxNodesPerSource, inactiveTime, soundCleanUpCallback) {\n    this._maxNodesPerSource = maxNodesPerSource;\n    this._inactiveTime = inactiveTime;\n    this._soundCleanUpCallback = soundCleanUpCallback;\n  }\n\n  /**\n   * Allocates an audio node for the passed source.\n   * @param {string} src The audio url.\n   * @return {Audio}\n   */\n  allocateForSource(src) {\n    this._createSrc(src);\n    this._checkMaxNodesForSrc(src);\n\n    const nodes = this._resourceNodesMap[src],\n      { unallocated } = nodes;\n\n    const audio = new Audio();\n    unallocated.push({ audio: audio, time: new Date() });\n\n    return audio;\n  }\n\n  /**\n   * Allocates a HTML5 audio node to a particular group.\n   * @param {string} src The audio url.\n   * @param {number} [groupId] The buzz group id.\n   * @return {Audio}\n   */\n  allocateForGroup(src, groupId) {\n    this._createGroup(src, groupId);\n    this._checkMaxNodesForSrc(src);\n\n    const nodes = this._resourceNodesMap[src],\n      { unallocated, allocated } = nodes,\n      audio = unallocated.length ? unallocated.shift().audio : new Audio();\n\n    allocated[groupId].push({ soundId: null, audio: audio, time: new Date() });\n\n    return audio;\n  }\n\n  /**\n   * Allocates the pre-loaded HTML5 audio node to a sound.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The group id.\n   * @param {number} soundId The sound id.\n   * @return {Audio}\n   */\n  allocateForSound(src, groupId, soundId) {\n    this._createGroup(src, groupId);\n\n    const nodes = this._resourceNodesMap[src],\n      { allocated } = nodes,\n      notAllocatedAudioObj = allocated[groupId].find(x => x.soundId === null);\n\n    if (!notAllocatedAudioObj) {\n      throw new Error(`No free audio nodes available in the group ${groupId}`);\n    }\n\n    notAllocatedAudioObj.soundId = soundId;\n\n    return notAllocatedAudioObj.audio;\n  }\n\n  /**\n   * Releases the audio nodes allocated for all resources.\n   */\n  release() {\n    Object.keys(this._resourceNodesMap).forEach(src => this.releaseForSource(src));\n  }\n\n  /**\n   * Releases the audio nodes allocated for a resource.\n   * @param {string} src The audio url.\n   */\n  releaseForSource(src) {\n    const nodes = this._resourceNodesMap[src],\n      { unallocated, allocated } = nodes;\n\n    unallocated.forEach(x => this._destroyNode(x.audio));\n\n    Object.keys(allocated).forEach(groupId => this.releaseForGroup(src, groupId));\n\n    delete this._resourceNodesMap[src];\n  }\n\n  /**\n   * Releases the audio nodes allocated for a group.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The group id.\n   */\n  releaseForGroup(src, groupId) {\n    const nodes = this._resourceNodesMap[src],\n      { allocated } = nodes;\n\n    allocated[groupId].map(x => x.audio).forEach(node => this._destroyNode(node));\n    delete allocated[groupId];\n  }\n\n  /**\n   * Destroys the audio node reserved for sound.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The buzz id.\n   * @param {number|Audio} soundIdOrAudio The sound id or audio.\n   */\n  releaseAudio(src, groupId, soundIdOrAudio) {\n    const nodes = this._resourceNodesMap[src],\n      { allocated, unallocated } = nodes;\n\n    if (soundIdOrAudio instanceof Audio) {\n      this._destroyNode(soundIdOrAudio);\n\n      if (groupId) {\n        allocated[groupId] = allocated[groupId].filter(x => x.audio !== soundIdOrAudio);\n      } else {\n        nodes.unallocated = unallocated.filter(x => x.audio !== soundIdOrAudio);\n      }\n    } else {\n      const allocatedAudioObj = allocated[groupId].find(x => x.soundId === soundIdOrAudio);\n      this._destroyNode(allocatedAudioObj.audio);\n      allocated[groupId] = allocated[groupId].filter(x => x.soundId !== soundIdOrAudio);\n    }\n\n    groupId && !allocated[groupId].length && delete allocated[groupId];\n    !unallocated.length && !Object.keys(allocated).length && delete this._resourceNodesMap[src];\n  }\n\n  /**\n   * Removes inactive HTML5 audio nodes.\n   */\n  cleanUp() {\n    const now = new Date();\n\n    Object.keys(this._resourceNodesMap).forEach(src => {\n      const nodes = this._resourceNodesMap[src],\n        { unallocated, allocated } = nodes;\n\n      Object.keys(allocated).forEach(groupId => {\n        const inactiveNodes = allocated[groupId]\n          .filter(x => x.soundId === null && ((now - x.time) / 1000 > this._inactiveTime * 60));\n\n        allocated[groupId] = allocated[groupId].filter(x => inactiveNodes.indexOf(x) === -1);\n\n        inactiveNodes.forEach(x => this._destroyNode(x.audio));\n      });\n\n      const inactiveNodes = unallocated.filter(x => ((now - x.time) / 1000 > this._inactiveTime * 60));\n      nodes.unallocated = unallocated.filter(x => inactiveNodes.indexOf(x) === -1);\n\n      inactiveNodes.forEach(x => this._destroyNode(x.audio));\n    });\n  }\n\n  /**\n   * Releases all the audio nodes.\n   */\n  dispose() {\n    Object.keys(this._resourceNodesMap).forEach(src => this.releaseForSource(src));\n  }\n\n  /**\n   * Returns true if there are free audio nodes available for a source or group.\n   * @param {string} src The audio file url.\n   * @param {number} [groupId] The group id.\n   * @return {boolean}\n   */\n  hasFreeNodes(src, groupId) {\n    if (!this._resourceNodesMap.hasOwnProperty(src)) {\n      return false;\n    }\n\n    const nodes = this._resourceNodesMap[src],\n      { unallocated, allocated } = nodes;\n\n    return !groupId ? unallocated.length > 0 : allocated[groupId].filter(x => x.soundId === null).length > 0;\n  }\n\n  /**\n   * Creates an entry for the passed source in object if not exists.\n   * @param {string} src The audio file.\n   * @private\n   */\n  _createSrc(src) {\n    if (this._resourceNodesMap.hasOwnProperty(src)) {\n      return;\n    }\n\n    this._resourceNodesMap[src] = {\n      unallocated: [],\n      allocated: {}\n    };\n  }\n\n  /**\n   * Creates an entry for the passed source and group if not exists.\n   * @param {string} src The audio file.\n   * @param {number} groupId The group id.\n   * @private\n   */\n  _createGroup(src, groupId) {\n    this._createSrc(src);\n\n    const nodes = this._resourceNodesMap[src],\n      { allocated } = nodes;\n\n    if (allocated.hasOwnProperty(groupId)) {\n      return;\n    }\n\n    allocated[groupId] = [];\n  }\n\n  /**\n   * Checks and throws error if max audio nodes reached for the passed resource.\n   * @param {string} src The source url.\n   * @private\n   */\n  _checkMaxNodesForSrc(src) {\n    if (!this._resourceNodesMap.hasOwnProperty(src)) {\n      return;\n    }\n\n    const nodes = this._resourceNodesMap[src],\n      { unallocated, allocated } = nodes;\n\n    let totalAllocatedLength = 0;\n\n    Object.keys(allocated).forEach(groupId => {\n      totalAllocatedLength = totalAllocatedLength + allocated[groupId].length;\n    });\n\n    if (unallocated.length + totalAllocatedLength < this._maxNodesPerSource) {\n      return;\n    }\n\n    if (!this._cleanUpCalled) {\n      this.cleanUp();\n      this._soundCleanUpCallback(src);\n      this._cleanUpCalled = true;\n      this._checkMaxNodesForSrc(src);\n    }\n\n    this._cleanUpCalled = false;\n\n    throw new Error(`Maximum nodes reached for resource ${src}`);\n  }\n\n  /**\n   * Destroys the passed audio node.\n   * @param {Audio} audio The HTML5 audio element.\n   * @private\n   */\n  _destroyNode(audio) {\n    audio.pause();\n    utility.isIE() && (audio.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');\n    audio.onerror = null;\n    audio.onend = null;\n    audio.canplaythrough = null;\n  }\n}\n\nexport default Html5AudioPool;\n","// Credit: https://github.com/goldfire/howler.js/issues/626\n\nconst WORKER_SCRIPT = `\n  var timerIds = {}, timeoutWorker = {};\n  \n  timeoutWorker.setTimeout = function(timerId, duration) {\n    timerIds[timerId] = setTimeout(function() {\n      postMessage({ timerId: timerId });\n    }, duration);\n  };\n  \n  timeoutWorker.clearTimeout = function(timerId) {\n    clearTimeout(timerIds[timerId]);\n  };\n  \n  timeoutWorker.setInterval = function(timerId, duration) {\n    timerIds[timerId] = setInterval(function() {\n      postMessage({ timerId: timerId });\n    }, duration);\n  };\n  \n  timeoutWorker.clearInterval = function(timerId) {\n    clearInterval(timerIds[timerId]);\n  };\n  \n  onmessage = function(e) {\n    var command = e.data.command;\n    timeoutWorker[command](e.data.timerId, e.data.duration);\n  };\n`;\n\n/**\n * Provides more accurate timeouts and intervals when the browser tab is not active using Web Workers.\n * @class\n */\nclass WorkerTimer {\n\n  /**\n   * Web worker.\n   * @type {Worker}\n   * @private\n   */\n  _worker = null;\n\n  /**\n   * Whether Web Worker is available or not. If not available then normal setTimeout and setInterval will be used.\n   * @type {boolean}\n   * @private\n   */\n  _isWorkerThreadAvailable = false;\n\n  /**\n   * Dictionary to store the callbacks that should be invoked after timeouts and intervals.\n   * @type {{}}\n   * @private\n   */\n  _timerCallbacks = {};\n\n  /**\n   * The incrementing id that is used to link the timer running in worker with the callback.\n   * @type {number}\n   * @private\n   */\n  _timerId = 0;\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    this._handleMessage = this._handleMessage.bind(this);\n  }\n\n  /**\n   * Initialize the worker\n   */\n  init() {\n    if (!Worker || this._worker) {\n      return;\n    }\n\n    let blob = this._getBlob(WORKER_SCRIPT);\n    if (blob === null) {\n      return;\n    }\n\n    let workerUrl = this._createObjectURL(blob);\n    if (workerUrl === null) {\n      return;\n    }\n\n    this._worker = new Worker(workerUrl);\n    this._worker.addEventListener('message', this._handleMessage);\n    this._isWorkerThreadAvailable = true;\n  }\n\n  /**\n   * Returns a blob.\n   * @param {string} script The javascript code string.\n   * @return {*}\n   * @private\n   */\n  _getBlob(script) {\n    let blob = null;\n\n    try {\n      blob = new Blob([script], { type: 'application/javascript' });\n    } catch (e) {\n      let blobBuilderType = null;\n\n      if (typeof BlobBuilder !== 'undefined') {\n        blobBuilderType = BlobBuilder;\n      } else if (typeof WebKitBlobBuilder !== 'undefined') {\n        blobBuilderType = WebKitBlobBuilder;\n      }\n\n      blob = new blobBuilderType(); // eslint-disable-line new-cap\n      blob.append(script);\n      blob = blob.getBlob();\n    }\n\n    return blob;\n  }\n\n  /**\n   * Returns object url.\n   * @param {*} file The blob.\n   * @return {*}\n   * @private\n   */\n  _createObjectURL(file) {\n    if (typeof URL !== 'undefined' && URL.createObjectURL) {\n      return URL.createObjectURL(file);\n    } else if (typeof webkitURL !== 'undefined') {\n      return webkitURL.createObjectURL(file);\n    }\n\n    return null;\n  }\n\n  /**\n   * Callback that handles the messages send by worker.\n   * @param {object} e Event argument that contains the message data and other information\n   * @private\n   */\n  _handleMessage(e) {\n    const callback = this._timerCallbacks[e.data.timerId];\n\n    if (callback && callback.cb) {\n      callback.cb();\n    }\n\n    if (!callback.repeat) {\n      delete this._timerCallbacks[e.data.timerId];\n    }\n  }\n\n  /**\n   * Invokes a callback after the passed time.\n   * @param {function} callback The callback that should be called after the elapsed period.\n   * @param {number} duration The time period in ms.\n   * @return {number}\n   */\n  setTimeout(callback, duration) {\n    if (!this._isWorkerThreadAvailable) {\n      return setTimeout(callback, duration);\n    }\n\n    this._timerId = this._timerId + 1;\n    this._timerCallbacks[this._timerId] = { cb: callback, repeat: false };\n    this._worker.postMessage({ command: 'setTimeout', timerId: this._timerId, duration: duration });\n    return this._timerId;\n  }\n\n  /**\n   * Clears the scheduled timeout.\n   * @param {number} timeoutId The timeout id.\n   */\n  clearTimeout(timeoutId) {\n    if (!this._isWorkerThreadAvailable) {\n      return clearTimeout(timeoutId);\n    }\n\n    this._worker.postMessage({ command: 'clearTimeout', timerId: timeoutId });\n    delete this._timerCallbacks[timeoutId];\n  }\n\n  /**\n   * Invokes the callback function at the passed interval.\n   * @param {function} callback The callback function.\n   * @param {number} duration The time interval.\n   * @return {number}\n   */\n  setInterval(callback, duration) {\n    if (!this._isWorkerThreadAvailable) {\n      return setInterval(callback, duration);\n    }\n\n    this._timerId = this._timerId + 1;\n    this._timerCallbacks[this._timerId] = { cb: callback, repeat: true };\n    this._worker.postMessage({ command: 'setInterval', timerId: this._timerId, duration: duration });\n    return this._timerId;\n  }\n\n  /**\n   * Clears the scheduled interval.\n   * @param {number} intervalId The interval id.\n   */\n  clearInterval(intervalId) {\n    if (!this._isWorkerThreadAvailable) {\n      return clearTimeout(intervalId);\n    }\n\n    this._worker.postMessage({ command: 'clearTimeout', timerId: intervalId });\n    delete this._timerCallbacks[intervalId];\n  }\n\n  /**\n   * Kills the worker thread.\n   */\n  terminate() {\n    if (this._worker) {\n      this._worker.removeEventListener('message', this._handleMessage);\n      this._worker.terminate();\n      this._worker = null;\n    }\n\n    this._isWorkerThreadAvailable = false;\n    this._timerCallbacks = {};\n    this._timerId = 0;\n  }\n}\n\nexport default new WorkerTimer();\n","/**\n * Enum that represents the different states occurs while loading a sound.\n * @enum {string}\n */\nconst LoadState = {\n  NotLoaded: 'notloaded',\n  Loading: 'loading',\n  Loaded: 'loaded'\n};\n\nexport default LoadState;\n"],"sourceRoot":""}